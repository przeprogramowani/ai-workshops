{
  "pl": {
    "cur01Codebase": "@Codebase Wdróż mnie w ten projekt. Poinformuj mnie o wykorzystywanych technologiach oraz strukturze projektu.\n",
    "cur02Docs": "@DummyJSON Opisz strukturę encji produktu, którą można pobrać z API.\n",
    "cur03WebDeps": "@Web Czy są nowsze, lżejsze, bezpieczniejsze alternatywy dla zależności, z których korzystam w projekcie?\n",
    "cur04WebLodash": "@Web Czy proponujesz jakieś alternatywy dla Lodasha? Interesują mnie rozwiązania, które są popularne i utrzymywane w {CURRENT_YEAR}.\n",
    "cur05UnitIntro": "Chcę dodać testy jednostkowe do @Cart.jsx. Zacznijmy od konfiguracji testów dla komponentu oraz prostego smoke testu. Pamiętaj, że wykorzystujemy w projekcie @Vitest oraz @React Testing Library.\n",
    "cur06UnitEdge": "Czy brakuje nam jakiegoś testu, który mógłby pokryć edge case?\n",
    "devD100FlashcardsMvp": "# Aplikacja - 10xCards MVP\n\n### Główny problem\nManualne tworzenie wysokiej jakości fiszek edukacyjnych jest czasochłonne, co zniechęca do korzystania z efektywnej metody nauki jaką jest spaced repetition.\n\n### Najmniejszy zestaw funkcjonalności\n- Generowanie fiszek przez AI na podstawie wprowadzonego tekstu (kopiuj-wklej)\n- Manualne tworzenie fiszek\n- Przeglądanie, edycja i usuwanie fiszek\n- Prosty system kont użytkowników do przechowywania fiszek\n- Integracja fiszek z gotowym algorytmem powtórek\n\n### Co NIE wchodzi w zakres MVP\n- Własny, zaawansowany algorytm powtórek (jak SuperMemo, Anki)\n- Import wielu formatów (PDF, DOCX, itp.)\n- Współdzielenie zestawów fiszek między użytkownikami\n- Integracje z innymi platformami edukacyjnymi\n- Aplikacje mobilne (na początek tylko web)\n\n### Kryteria sukcesu\n- 75% fiszek wygenerowanych przez AI jest akceptowane przez użytkownika\n- Użytkownicy tworzą 75% fiszek z wykorzystaniem AI",
    "devD101PrdPlanning": "Jesteś doświadczonym menedżerem produktu, którego zadaniem jest pomoc w stworzeniu kompleksowego dokumentu wymagań projektowych (PRD) na podstawie dostarczonych informacji. Twoim celem jest wygenerowanie listy pytań i zaleceń, które zostaną wykorzystane w kolejnym promptowaniu do utworzenia pełnego PRD.\n\nProsimy o uważne zapoznanie się z poniższymi informacjami:\n\n<project_description>\n{{project-highlevel}} <- przekopiuj wysokopoziomowy opis projektu\n</project_description>\n\nPrzeanalizuj dostarczone informacje, koncentrując się na aspektach istotnych dla tworzenia PRD. Rozważ następujące kwestie:\n<prd_analysis>\n1. Zidentyfikuj główny problem, który produkt ma rozwiązać.\n2. Określ kluczowe funkcjonalności MVP.\n3. Rozważ potencjalne historie użytkownika i ścieżki korzystania z produktu.\n4. Pomyśl o kryteriach sukcesu i sposobach ich mierzenia.\n5. Oceń ograniczenia projektowe i ich wpływ na rozwój produktu.\n</prd_analysis>\n\nNa podstawie analizy wygeneruj listę pytań i zaleceń. Powinny one dotyczyć wszelkich niejasności, potencjalnych problemów lub obszarów, w których potrzeba więcej informacji, aby stworzyć skuteczny PRD. Rozważ pytania dotyczące:\n\n1. Szczegółów problemu użytkownika\n2. Priorytetyzacji funkcjonalności\n3. Oczekiwanego doświadczenia użytkownika\n4. Mierzalnych wskaźników sukcesu\n5. Potencjalnych ryzyk i wyzwań\n6. Harmonogramu i zasobów\n\n<pytania>\n[Wymień tutaj swoje pytania, ponumerowane dla jasności].\n</pytania>\n\n<rekomendacje>\n[Wymień tutaj swoje zalecenia, ponumerowane dla jasności]\n</rekomendacje>\n\nKontynuuj ten proces, generując nowe pytania i rekomendacje w oparciu o odpowiedzi użytkownika, dopóki użytkownik wyraźnie nie poprosi o podsumowanie.\n\nPamiętaj, aby skupić się na jasności, trafności i dokładności wyników. Nie dołączaj żadnych dodatkowych komentarzy ani wyjaśnień poza określonym formatem wyjściowym.\n\nPracę analityczną należy przeprowadzić w bloku myślenia. Końcowe dane wyjściowe powinny składać się wyłącznie z pytań i zaleceń i nie powinny powielać ani powtarzać żadnej pracy wykonanej w sekcji prd_analysis.",
    "devD102PrdPlanningSum": "{{latest-round-answers}} < twoja lista odpowiedzi na ostatnią rundę pytań\n\n---\n\nJesteś asystentem AI, którego zadaniem jest podsumowanie rozmowy na temat planowania PRD (Product Requirements Document) dla MVP i przygotowanie zwięzłego podsumowania dla następnego etapu rozwoju. W historii konwersacji znajdziesz następujące informacje:\n1. Opis projektu\n2. Zidentyfikowany problem użytkownika\n3. Historia rozmów zawierająca pytania i odpowiedzi\n4. Zalecenia dotyczące zawartości PRD\n\nTwoim zadaniem jest:\n1. Podsumować historię konwersacji, koncentrując się na wszystkich decyzjach związanych z planowaniem PRD.\n2. Dopasowanie zaleceń modelu do odpowiedzi udzielonych w historii konwersacji. Zidentyfikuj, które zalecenia są istotne w oparciu o dyskusję.\n3. Przygotuj szczegółowe podsumowanie rozmowy, które obejmuje:\n   a. Główne wymagania funkcjonalne produktu\n   b. Kluczowe historie użytkownika i ścieżki korzystania\n   c. Ważne kryteria sukcesu i sposoby ich mierzenia\n   d. Wszelkie nierozwiązane kwestie lub obszary wymagające dalszego wyjaśnienia\n4. Sformatuj wyniki w następujący sposób:\n\n<conversation_summary>\n<decisions>\n[Wymień decyzje podjęte przez użytkownika, ponumerowane].\n</decisions>\n\n<matched_recommendations>\n[Lista najistotniejszych zaleceń dopasowanych do rozmowy, ponumerowanych]\n</matched_recommendations>\n\n<prd_planning_summary>\n[Podaj szczegółowe podsumowanie rozmowy, w tym elementy wymienione w kroku 3].\n</prd_planning_summary>\n\n<unresolved_issues>\n[Wymień wszelkie nierozwiązane kwestie lub obszary wymagające dalszych wyjaśnień, jeśli takie istnieją]\n</unresolved_issues>\n</conversation_summary>\n\nKońcowy wynik powinien zawierać tylko treść w formacie markdown. który zapiszesz w pliku docs/prd-planning-summary.md. Upewnij się, że Twoje podsumowanie jest jasne, zwięzłe i zapewnia cenne informacje dla następnego etapu tworzenia PRD.\n",
    "devD103PrdGeneration": "Jesteś doświadczonym menedżerem produktu, którego zadaniem jest stworzenie kompleksowego dokumentu wymagań produktu (PRD) w oparciu o poniższe opisy:\n\n<project_description>\n{{project-description}} <- wprowadź pomysł na MVP\n</project_description>\n\n<project_details>\n{{project-details}} <- wprowadź podsumowanie sesji planistycznej\n</project_details>\n\nWykonaj następujące kroki, aby stworzyć kompleksowy i dobrze zorganizowany dokument:\n\n1. Podziel PRD na następujące sekcje:\n   a. Przegląd projektu\n   b. Problem użytkownika\n   c. Wymagania funkcjonalne\n   d. Granice projektu\n   e. Historie użytkownika\n   f. Metryki sukcesu\n\n2. W każdej sekcji należy podać szczegółowe i istotne informacje w oparciu o opis projektu i odpowiedzi na pytania wyjaśniające. Upewnij się, że:\n   - Używasz jasnego i zwięzłego języka\n   - W razie potrzeby podajesz konkretne szczegóły i dane\n   - Zachowujesz spójność w całym dokumencie\n   - Odnosisz się do wszystkich punktów wymienionych w każdej sekcji\n\n3. Podczas tworzenia historyjek użytkownika i kryteriów akceptacji\n   - Wymień WSZYSTKIE niezbędne historyjki użytkownika, w tym scenariusze podstawowe, alternatywne i skrajne.\n   - Przypisz unikalny identyfikator wymagań (np. US-001) do każdej historyjki użytkownika w celu bezpośredniej identyfikowalności.\n   - Uwzględnij co najmniej jedną historię użytkownika specjalnie dla bezpiecznego dostępu lub uwierzytelniania, jeśli aplikacja wymaga identyfikacji użytkownika lub ograniczeń dostępu.\n   - Upewnij się, że żadna potencjalna interakcja użytkownika nie została pominięta.\n   - Upewnij się, że każda historia użytkownika jest testowalna.\n\nUżyj następującej struktury dla każdej historii użytkownika:\n- ID\n- Tytuł\n- Opis\n- Kryteria akceptacji\n\n4. Po ukończeniu PRD przejrzyj go pod kątem tej listy kontrolnej:\n   - Czy każdą historię użytkownika można przetestować?\n   - Czy kryteria akceptacji są jasne i konkretne?\n   - Czy mamy wystarczająco dużo historyjek użytkownika, aby zbudować w pełni funkcjonalną aplikację?\n   - Czy uwzględniliśmy wymagania dotyczące uwierzytelniania i autoryzacji (jeśli dotyczy)?\n\n5. Formatowanie PRD:\n   - Zachowaj spójne formatowanie i numerację.\n   - Nie używaj pogrubionego formatowania w markdown ( ** ).\n   - Wymień WSZYSTKIE historyjki użytkownika.\n   - Sformatuj PRD w poprawnym markdown.\n\nPrzygotuj PRD z następującą strukturą:\n\n```markdown\n# Dokument wymagań produktu (PRD) - {{app-name}}\n## 1. Przegląd produktu\n## 2. Problem użytkownika\n## 3. Wymagania funkcjonalne\n## 4. Granice produktu\n## 5. Historyjki użytkowników\n## 6. Metryki sukcesu\n```\n\nPamiętaj, aby wypełnić każdą sekcję szczegółowymi, istotnymi informacjami w oparciu o opis projektu i nasze pytania wyjaśniające. Upewnij się, że PRD jest wyczerpujący, jasny i zawiera wszystkie istotne informacje potrzebne do dalszej pracy nad produktem.\n\nOstateczny wynik powinien składać się wyłącznie z PRD zgodnego ze wskazanym formatem w markdown, który zapiszesz w pliku docs/prd.md",
    "devD104DbPlanning": "Jesteś asystentem AI, którego zadaniem jest pomoc w zaplanowaniu schematu bazy danych w PostgreSQL dla MVP (Minimum Viable Product) na podstawie dostarczonych informacji. Twoim celem jest wygenerowanie listy pytań i zaleceń, które zostaną wykorzystane w kolejnym promptowaniu do utworzenia schematu bazy danych, relacji i zasad bezpieczeństwa na poziomie wierszy (RLS).\n\nProsimy o uważne zapoznanie się z poniższymi informacjami:\n\n<product_requirements>\n{{prd}} <- zamień na referencję do @prd.md\n</product_requirements>\n\n<tech_stack>\n{{tech-stack}} <- zamień na referencję do @tech-stack.md\n</tech_stack>\n\nPrzeanalizuj dostarczone informacje, koncentrując się na aspektach istotnych dla projektowania bazy danych. Rozważ następujące kwestie:\n\n1. Zidentyfikuj kluczowe encje i ich atrybuty na podstawie wymagań produktu.\n2. Określ potencjalne relacje między jednostkami.\n3. Rozważ typów danych i ograniczeń, które mogą być konieczne.\n4. Pomyśl o skalowalności i wpływie na wydajność.\n5. Oceń wymagania bezpieczeństwa i ich wpływ na projekt bazy danych.\n6. Rozważ wszelkie konkretne funkcje PostgreSQL, które mogą być korzystne dla projektu.\n\nNa podstawie analizy wygeneruj listę pytań i zaleceń. Powinny one dotyczyć wszelkich niejasności, potencjalnych problemów lub obszarów, w których potrzeba więcej informacji, aby stworzyć skuteczny schemat bazy danych. Rozważ pytania dotyczące:\n\n1. Relacje i kardynalność jednostek\n2. Typy danych i ograniczenia\n3. Strategie indeksowania\n4. Partycjonowanie (jeśli dotyczy)\n5. Wymagania bezpieczeństwa na poziomie wierszy\n6. Rozważania dotyczące wydajności\n7. Kwestie skalowalności\n8. Integralność i spójność danych\n\nDane wyjściowe powinny mieć następującą strukturę:\n\n<database_planning_output>\n<pytania>\n[Wymień tutaj swoje pytania, ponumerowane]\n</pytania>\n\n<rekomendacje>\n[Wymień tutaj swoje zalecenia, ponumerowane]\n</rekomendacje>\n</database_planning_output>\n\nPamiętaj, że Twoim celem jest dostarczenie kompleksowej listy pytań i zaleceń, które pomogą w stworzeniu solidnego schematu bazy danych PostgreSQL dla MVP. Skoncentruj się na jasności, trafności i dokładności swoich wyników. Nie dołączaj żadnych dodatkowych komentarzy ani wyjaśnień poza określonym formatem wyjściowym.\n\nKontynuuj ten proces, generując nowe pytania i rekomendacje w oparciu o przekazany kontekst i odpowiedzi użytkownika, dopóki użytkownik wyraźnie nie poprosi o podsumowanie.\n\nPamiętaj, aby skupić się na jasności, trafności i dokładności wyników. Nie dołączaj żadnych dodatkowych komentarzy ani wyjaśnień poza określonym formatem wyjściowym.",
    "devD105DbPlanningSum": "{{latest-round-answers}} < lista odpowiedzi na drugą rundę pytań\n\n---\n\nJesteś asystentem AI, którego zadaniem jest podsumowanie rozmowy na temat planowania bazy danych dla MVP i przygotowanie zwięzłego podsumowania dla następnego etapu rozwoju. W historii konwersacji znajdziesz następujące informacje:\n1. Dokument wymagań produktu (PRD)\n2. Informacje o stacku technologicznym\n3. Historia rozmów zawierająca pytania i odpowiedzi\n4. Zalecenia dotyczące modelu\n\nTwoim zadaniem jest:\n1. Podsumować historii konwersacji, koncentrując się na wszystkich decyzjach związanych z planowaniem bazy danych.\n2. Dopasowanie zaleceń modelu do odpowiedzi udzielonych w historii konwersacji. Zidentyfikuj, które zalecenia są istotne w oparciu o dyskusję.\n3. Przygotuj szczegółowe podsumowanie rozmowy, które obejmuje:\n   a. Główne wymagania dotyczące schematu bazy danych\n   b. Kluczowe encje i ich relacje\n   c. Ważne kwestie dotyczące bezpieczeństwa i skalowalności\n   d. Wszelkie nierozwiązane kwestie lub obszary wymagające dalszego wyjaśnienia\n4. Sformatuj wyniki w następujący sposób:\n\n<conversation_summary>\n<decisions>\n[Wymień decyzje podjęte przez użytkownika, ponumerowane].\n</decisions>\n\n<matched_recommendations>\n[Lista najistotniejszych zaleceń dopasowanych do rozmowy, ponumerowanych]\n</matched_recommendations>\n\n<database_planning_summary> [Podsumowanie planowania bazy danych]\n[Podaj szczegółowe podsumowanie rozmowy, w tym elementy wymienione w kroku 3].\n</database_planning_summary>\n\n<unresolved_issues>\n[Wymień wszelkie nierozwiązane kwestie lub obszary wymagające dalszych wyjaśnień, jeśli takie istnieją]\n</unresolved_issues>\n</conversation_summary>\n\nKońcowy wynik powinien zawierać tylko treść w formacie markdown w pliku docs/db-planning-summary.md. Upewnij się, że Twoje podsumowanie jest jasne, zwięzłe i zapewnia cenne informacje dla następnego etapu planowania bazy danych.",
    "devD106DbPlanGeneration": "Jesteś architektem baz danych, którego zadaniem jest stworzenie schematu bazy danych PostgreSQL na podstawie informacji dostarczonych z sesji planowania, dokumentu wymagań produktu (PRD) i stacku technologicznym. Twoim celem jest zaprojektowanie wydajnej i skalowalnej struktury bazy danych, która spełnia wymagania projektu.\n\n1. <prd>\n{{prd}} <- zamień na referencję do @prd.md\n</prd>\n\nJest to dokument wymagań produktu, który określa cechy, funkcjonalności i wymagania projektu.\n\n2. <session_notes>\n{{session-notes}} <- wklej podsumowanie sesji planistycznej\n</session_notes>\n\nSą to notatki z sesji planowania schematu bazy danych. Mogą one zawierać ważne decyzje, rozważania i konkretne wymagania omówione podczas spotkania.\n\n3. <tech_stack>\n{{tech-stack}} <- zamień na referencje do tech-stack.md\n</tech_stack>\n\nOpisuje stack technologiczny, który zostanie wykorzystany w projekcie, co może wpłynąć na decyzje dotyczące projektu bazy danych.\n\nWykonaj następujące kroki, aby utworzyć schemat bazy danych:\n\n1. Dokładnie przeanalizuj notatki z sesji, identyfikując kluczowe jednostki, atrybuty i relacje omawiane podczas sesji planowania.\n2. Przejrzyj PRD, aby upewnić się, że wszystkie wymagane funkcje i funkcjonalności są obsługiwane przez schemat bazy danych.\n3. Przeanalizuj stack technologiczny i upewnij się, że projekt bazy danych jest zoptymalizowany pod kątem wybranych technologii.\n\n4. Stworzenie kompleksowego schematu bazy danych, który obejmuje\n   a. Tabele z odpowiednimi nazwami kolumn i typami danych\n   b. Klucze podstawowe i klucze obce\n   c. Indeksy poprawiające wydajność zapytań\n   d. Wszelkie niezbędne ograniczenia (np. unikalność, not null)\n\n5. Zdefiniuj relacje między tabelami, określając kardynalność (jeden-do-jednego, jeden-do-wielu, wiele-do-wielu) i wszelkie tabele łączące wymagane dla relacji wiele-do-wielu.\n\n6. Opracowanie zasad PostgreSQL dla zabezpieczeń na poziomie wiersza (RLS), jeśli dotyczy, w oparciu o wymagania określone w notatkach z sesji lub PRD.\n\n7. Upewnij się, że schemat jest zgodny z najlepszymi praktykami projektowania baz danych, w tym normalizacji do odpowiedniego poziomu (zwykle 3NF, chyba że denormalizacja jest uzasadniona ze względu na wydajność).\n\nOstateczny wynik powinien mieć następującą strukturę:\n```markdown\n1. Lista tabel z ich kolumnami, typami danych i ograniczeniami\n2. Relacje między tabelami\n3. Indeksy\n4. Zasady PostgreSQL (jeśli dotyczy)\n5. Wszelkie dodatkowe uwagi lub wyjaśnienia dotyczące decyzji projektowych\n```\n\nW odpowiedzi należy podać tylko ostateczny schemat bazy danych w formacie markdown, który zapiszesz w pliku docs/db-plan.md bez uwzględniania procesu myślowego lub kroków pośrednich. Upewnij się, że schemat jest kompleksowy, dobrze zorganizowany i gotowy do wykorzystania jako podstawa do tworzenia migracji baz danych.",
    "devD107DbMigration": "# Database: Create migration\n\nYou are a Postgres Expert who loves creating secure database schemas.\n\nThis project uses the migrations provided by the Supabase CLI.\n\n<db-plan>\n@db-plan.md <- zamień na referencję do @db-plan.md\n</db-plan>\n\n## Creating a migration file\n\nGiven the context in <db-plan>, create a database migration file inside the folder `supabase/migrations/`.\n\nThe file MUST following this naming convention:\n\nThe file MUST be named in the format `YYYYMMDDHHmmss_short_description.sql` with proper casing for months, minutes, and seconds in UTC time:\n\n1. `YYYY` - Four digits for the year (e.g., `2024`).\n2. `MM` - Two digits for the month (01 to 12).\n3. `DD` - Two digits for the day of the month (01 to 31).\n4. `HH` - Two digits for the hour in 24-hour format (00 to 23).\n5. `mm` - Two digits for the minute (00 to 59).\n6. `ss` - Two digits for the second (00 to 59).\n7. Add an appropriate description for the migration.\n\nFor example:\n\n```\n20240906123045_create_profiles.sql\n```\n\n## SQL Guidelines\n\nWrite Postgres-compatible SQL code for Supabase migration files that:\n\n- Includes a header comment with metadata about the migration, such as the purpose, affected tables/columns, and any special considerations.\n- Includes thorough comments explaining the purpose and expected behavior of each migration step.\n- Write all SQL in lowercase.\n- Add copious comments for any destructive SQL commands, including truncating, dropping, or column alterations.\n- When creating a new table, you MUST enable Row Level Security (RLS) even if the table is intended for public access.\n- When creating RLS Policies\n  - Ensure the policies cover all relevant access scenarios (e.g. select, insert, update, delete) based on the table's purpose and data sensitivity.\n  - If the table  is intended for public access the policy can simply return `true`.\n  - RLS Policies should be granular: one policy for `select`, one for `insert` etc) and for each supabase role (`anon` and `authenticated`). DO NOT combine Policies even if the functionality is the same for both roles.\n  - Include comments explaining the rationale and intended behavior of each security policy\n\nThe generated SQL code should be production-ready, well-documented, and aligned with Supabase's best practices.",
    "devD201ApiSupabaseInt": "# Supabase Astro Initialization\n\nThis document provides a reproducible guide to create the necessary file structure for integrating Supabase with your Astro project.\n\n## Prerequisites\n\n- Your project should use Astro 5, TypeScript 5, React 19, and Tailwind 4.\n- Install the `@supabase/supabase-js` package.\n- Ensure that `/supabase/config.toml` exists\n- Ensure that a file `/src/db/database.types.ts` exists and contains the correct type definitions for your database.\n\nIMPORTANT: Check prerequisites before perfoming actions below. If they're not met, stop and ask a user for the fix.\n\n## File Structure and Setup\n\n### 1. Supabase Client Initialization\n\nCreate the file `/src/db/supabase.client.ts` with the following content:\n\n```ts\nimport { createClient } from '@supabase/supabase-js';\n\nimport type { Database } from '../db/database.types.ts';\n\nconst supabaseUrl = import.meta.env.SUPABASE_URL;\nconst supabaseAnonKey = import.meta.env.SUPABASE_KEY;\n\nexport const supabaseClient = createClient<Database>(supabaseUrl, supabaseAnonKey);\n```\n\nThis file initializes the Supabase client using the environment variables `SUPABASE_URL` and `SUPABASE_KEY`.\n\n\n### 2. Middleware Setup\n\nCreate the file `/src/middleware/index.ts` with the following content:\n\n```ts\nimport { defineMiddleware } from 'astro:middleware';\n\nimport { supabaseClient } from '../db/supabase.client.ts';\n\nexport const onRequest = defineMiddleware((context, next) => {\n  context.locals.supabase = supabaseClient;\n  return next();\n});\n```\n\nThis middleware adds the Supabase client to the Astro context locals, making it available throughout your application.\n\n\n### 3. TypeScript Environment Definitions\n\nCreate the file `src/env.d.ts` with the following content:\n\n```ts\n/// <reference types=\"astro/client\" />\n\nimport type { SupabaseClient } from '@supabase/supabase-js';\nimport type { Database } from './db/database.types.ts';\n\ndeclare global {\n  namespace App {\n    interface Locals {\n      supabase: SupabaseClient<Database>;\n    }\n  }\n}\n\ninterface ImportMetaEnv {\n  readonly SUPABASE_URL: string;\n  readonly SUPABASE_KEY: string;\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv;\n}\n```\n\nThis file augments the global types to include the Supabase client on the Astro `App.Locals` object, ensuring proper typing throughout your application.",
    "devD202ApiPlanGen": "<db-plan>\n{{db-plan}} < zamień na referencję do @db-plan.md\n<db-plan>\n\n<prd>\n{{prd}} <- zamień na referencję do @prd.md\n</prd>\n\n<tech-stack>\n{{tech-stack}} <- zamień na referencję do @tech-stack.md\n</tech-stack>\n\nJesteś doświadczonym architektem API, którego zadaniem jest stworzenie kompleksowego planu API REST. Twój plan będzie oparty na podanym schemacie bazy danych, dokumencie wymagań produktu (PRD) i stacku technologicznym podanym powyżej. Uważnie przejrzyj dane wejściowe i wykonaj następujące kroki:\n\n1. Przeanalizuj schemat bazy danych:\n   - Zidentyfikuj główne encje (tabele)\n   - Zanotuj relacje między jednostkami\n   - Rozważ wszelkie indeksy, które mogą mieć wpływ na projekt API\n   - Zwróć uwagę na warunki walidacji określone w schemacie.\n\n2. Przeanalizuj PRD:\n   - Zidentyfikuj kluczowe cechy i funkcjonalności\n   - Zwróć uwagę na konkretne wymagania dotyczące operacji na danych (pobieranie, tworzenie, aktualizacja, usuwanie)\n   - Zidentyfikuj wymagania logiki biznesowej, które wykraczają poza operacje CRUD\n\n3. Rozważ stack technologiczny:\n   - Upewnij się, że plan API jest zgodny z określonymi technologiami.\n   - Rozważ, w jaki sposób te technologie mogą wpłynąć na projekt API\n\n4. Tworzenie kompleksowego planu interfejsu API REST:\n   - Zdefiniowanie głównych zasobów w oparciu o encje bazy danych i wymagania PRD\n   - Zaprojektowanie punktów końcowych CRUD dla każdego zasobu\n   - Zaprojektuj punkty końcowe dla logiki biznesowej opisanej w PRD\n   - Uwzględnienie paginacji, filtrowania i sortowania dla punktów końcowych listy.\n   - Zaplanuj odpowiednie użycie metod HTTP\n   - Zdefiniowanie struktur ładunku żądania i odpowiedzi\n   - Uwzględnienie mechanizmów uwierzytelniania i autoryzacji, jeśli wspomniano o nich w PRD\n   - Rozważenie ograniczenia szybkości i innych środków bezpieczeństwa\n\nPrzed dostarczeniem ostatecznego planu, pracuj wewnątrz tagów <api_analysis> w swoim bloku myślenia, aby rozbić swój proces myślowy i upewnić się, że uwzględniłeś wszystkie niezbędne aspekty. W tej sekcji:\n\n1. Wymień główne encje ze schematu bazy danych. Ponumeruj każdą encję i zacytuj odpowiednią część schematu.\n2. Wymień kluczowe funkcje logiki biznesowej z PRD. Ponumeruj każdą funkcję i zacytuj odpowiednią część PRD.\n3. Zmapuj funkcje z PRD do potencjalnych punktów końcowych API. Dla każdej funkcji rozważ co najmniej dwa możliwe projekty punktów końcowych i wyjaśnij, który z nich wybrałeś i dlaczego.\n4. Rozważ i wymień wszelkie wymagania dotyczące bezpieczeństwa i wydajności. Dla każdego wymagania zacytuj część dokumentów wejściowych, która je obsługuje.\n5. Wyraźnie mapuj logikę biznesową z PRD na punkty końcowe API.\n6. Uwzględnienie warunków walidacji ze schematu bazy danych w planie API.\n\nTa sekcja może być dość długa.\n\nOstateczny plan API powinien być sformatowany w markdown i zawierać następujące sekcje:\n\n``markdown\n# REST API Plan\n\n## 1. Zasoby\n- Wymień każdy główny zasób i odpowiadającą mu tabelę bazy danych\n\n## 2. Punkty końcowe\nDla każdego zasobu podaj:\n- Metoda HTTP\n- Ścieżka URL\n- Krótki opis\n- Parametry zapytania (jeśli dotyczy)\n- Struktura ładunku żądania JSON (jeśli dotyczy)\n- Struktura ładunku odpowiedzi JSON\n- Kody i komunikaty powodzenia\n- Kody i komunikaty błędów\n\n## 3. Uwierzytelnianie i autoryzacja\n- Opisz wybrany mechanizm uwierzytelniania i szczegóły implementacji\n\n## 4. Walidacja i logika biznesowa\n- Lista warunków walidacji dla każdego zasobu\n- Opisz, w jaki sposób logika biznesowa jest zaimplementowana w API\n```\n\nUpewnij się, że Twój plan jest kompleksowy, dobrze skonstruowany i odnosi się do wszystkich aspektów materiałów wejściowych. Jeśli musisz przyjąć jakieś założenia z powodu niejasnych informacji wejściowych, określ je wyraźnie w swojej analizie.\n\nKońcowy wynik powinien składać się wyłącznie z planu API w formacie markdown w języku angielskim, który zapiszesz w docs/api-plan.md i nie powinien powielać ani powtarzać żadnej pracy wykonanej w bloku myślenia.",
    "devD203ApiTypes": "Jesteś wykwalifikowanym programistą TypeScript, którego zadaniem jest stworzenie biblioteki typów DTO (Data Transfer Object) i Command Model dla aplikacji. Twoim zadaniem jest przeanalizowanie definicji modelu bazy danych i planu API, a następnie utworzenie odpowiednich typów DTO, które dokładnie reprezentują struktury danych wymagane przez API, zachowując jednocześnie połączenie z podstawowymi modelami bazy danych.\n\nNajpierw dokładnie przejrzyj następujące dane wejściowe:\n\n1. Modele bazy danych:\n<database_models>\n{{db-models}} <- zamień na referencję do typów wygenerowanych z db (np. @database.types.ts)\n</database_models>\n\n2. Plan API (zawierający zdefiniowane DTO):\n<api_plan>\n{{api-plan}} <- zamień na referencję do @api-plan.md\n</api_plan>\n\nTwoim zadaniem jest utworzenie definicji typów TypeScript dla DTO i Command Modeli określonych w planie API, upewniając się, że pochodzą one z modeli bazy danych. Wykonaj następujące kroki:\n\n1. Przeanalizuj modele bazy danych i plan API.\n2. Utwórz typy DTO i Command Modele na podstawie planu API, wykorzystując definicje encji bazy danych.\n3. Zapewnienie zgodności między DTO i Command Modeli a wymaganiami API.\n4. Stosowanie odpowiednich funkcji języka TypeScript w celu tworzenia, zawężania lub rozszerzania typów zgodnie z potrzebami.\n5. Wykonaj końcowe sprawdzenie, aby upewnić się, że wszystkie DTO są uwzględnione i prawidłowo połączone z definicjami encji.\n\nPrzed utworzeniem ostatecznego wyniku, pracuj wewnątrz tagów <dto_analysis> w swoim bloku myślenia, aby pokazać swój proces myślowy i upewnić się, że wszystkie wymagania są spełnione. W swojej analizie:\n- Wymień wszystkie DTO i Command Modele zdefiniowane w planie API, numerując każdy z nich.\n- Dla każdego DTO i Comand Modelu:\n - Zidentyfikuj odpowiednie encje bazy danych i wszelkie niezbędne transformacje typów.\n  - Opisz funkcje lub narzędzia TypeScript, których planujesz użyć.\n  - Utwórz krótki szkic struktury DTO i Command Modelu.\n- Wyjaśnij, w jaki sposób zapewnisz, że każde DTO i Command Model jest bezpośrednio lub pośrednio połączone z definicjami typów encji.\n\nPo przeprowadzeniu analizy, podaj ostateczne definicje typów DTO i Command Modeli, które pojawią się w pliku src/types.ts. Użyj jasnych i opisowych nazw dla swoich typów i dodaj komentarze, aby wyjaśnić złożone manipulacje typami lub nieoczywiste relacje.\n\nPamiętaj:\n- Upewnij się, że wszystkie DTO i Command Modele zdefiniowane w planie API są uwzględnione.\n- Każdy DTO i Command Model powinien bezpośrednio odnosić się do jednej lub więcej encji bazy danych.\n- W razie potrzeby używaj funkcji TypeScript, takich jak Pick, Omit, Partial itp.\n- Dodaj komentarze, aby wyjaśnić złożone lub nieoczywiste manipulacje typami.\n\nKońcowy wynik powinien składać się wyłącznie z definicji typów DTO i Command Model, które zapiszesz w pliku src/types.ts, bez powielania lub ponownego wykonywania jakiejkolwiek pracy wykonanej w bloku myślenia.",
    "devD204ApiGenerations": "Jesteś doświadczonym architektem oprogramowania, którego zadaniem jest stworzenie szczegółowego planu wdrożenia punktu końcowego REST API. Twój plan poprowadzi zespół programistów w skutecznym i poprawnym wdrożeniu tego punktu końcowego.\n\nZanim zaczniemy, zapoznaj się z poniższymi informacjami:\n\n1. Route API specification:\n<route_api_specification>\n{{route-api-specification}} <- przekopiuj opis endpointa z api-plan.md\n</route_api_specification>\n\n2. Related database resources:\n<related_db_resources>\n{{db-resources}} <- przekopiuj z tabele i relacje z db-plan.md\n</related_db_resources>\n\n3. Definicje typów:\n<type_definitions>\n{{types}} <- zamień na referencje do definicji typów (np. @types)\n</type_definitions>\n\n3. Tech stack:\n<tech_stack>\n{{tech-stack}} <- zamień na referencje do @tech-stack.md\n</tech_stack>\n\n4. Implementation rules:\n<implementation_rules>\n{{backend-rules}} <- zamień na referencje do Rules for AI dla backendu (np. @shared.mdc, @backend.mdc, @astro.mdc)\n</implementation_rules>\n\nTwoim zadaniem jest stworzenie kompleksowego planu wdrożenia endpointu interfejsu API REST. Przed dostarczeniem ostatecznego planu użyj znaczników <analysis>, aby przeanalizować informacje i nakreślić swoje podejście. W tej analizie upewnij się, że:\n\n1. Podsumuj kluczowe punkty specyfikacji API.\n2. Wymień wymagane i opcjonalne parametry ze specyfikacji API.\n3. Wymień niezbędne typy DTO i Command Modele.\n4. Zastanów się, jak wyodrębnić logikę do service (istniejącego lub nowego, jeśli nie istnieje).\n5. Zaplanuj walidację danych wejściowych zgodnie ze specyfikacją API endpointa, zasobami bazy danych i regułami implementacji.\n6. Określenie sposobu rejestrowania błędów w tabeli błędów (jeśli dotyczy).\n7. Identyfikacja potencjalnych zagrożeń bezpieczeństwa w oparciu o specyfikację API i stack technologiczny.\n8. Nakreśl potencjalne scenariusze błędów i odpowiadające im kody stanu.\n\nPo przeprowadzeniu analizy utwórz szczegółowy plan wdrożenia w formacie markdown. Plan powinien zawierać następujące sekcje:\n\n1. Przegląd punktu końcowego\n2. Szczegóły żądania\n3. Szczegóły odpowiedzi\n4. Przepływ danych\n5. Względy bezpieczeństwa\n6. Obsługa błędów\n7. Wydajność\n8. Kroki implementacji\n\nW całym planie upewnij się, że\n- Używać prawidłowych kodów stanu API:\n  - 200 dla pomyślnego odczytu\n  - 201 dla pomyślnego utworzenia\n  - 400 dla nieprawidłowych danych wejściowych\n  - 401 dla nieautoryzowanego dostępu\n  - 404 dla nie znalezionych zasobów\n  - 500 dla błędów po stronie serwera\n- Dostosowanie do dostarczonego stacku technologicznego\n- Postępuj zgodnie z podanymi zasadami implementacji\n\nKońcowym wynikiem powinien być dobrze zorganizowany plan wdrożenia w formacie markdown. Oto przykład tego, jak powinny wyglądać dane wyjściowe:\n\n``markdown\n# API Endpoint Implementation Plan: [Nazwa punktu końcowego]\n\n## 1. Przegląd punktu końcowego\n[Krótki opis celu i funkcjonalności punktu końcowego]\n\n## 2. Szczegóły żądania\n- Metoda HTTP: [GET/POST/PUT/DELETE]\n- Struktura URL: [wzorzec URL]\n- Parametry:\n  - Wymagane: [Lista wymaganych parametrów]\n  - Opcjonalne: [Lista opcjonalnych parametrów]\n- Request Body: [Struktura treści żądania, jeśli dotyczy]\n\n## 3. Wykorzystywane typy\n[DTOs i Command Modele niezbędne do implementacji]\n\n## 3. Szczegóły odpowiedzi\n[Oczekiwana struktura odpowiedzi i kody statusu]\n\n## 4. Przepływ danych\n[Opis przepływu danych, w tym interakcji z zewnętrznymi usługami lub bazami danych]\n\n## 5. Względy bezpieczeństwa\n[Szczegóły uwierzytelniania, autoryzacji i walidacji danych]\n\n## 6. Obsługa błędów\n[Lista potencjalnych błędów i sposób ich obsługi]\n\n## 7. Rozważania dotyczące wydajności\n[Potencjalne wąskie gardła i strategie optymalizacji]\n\n## 8. Etapy wdrożenia\n1. [Krok 1]\n2. [Krok 2]\n3. [Krok 3]\n...\n```\n\nKońcowe wyniki powinny składać się wyłącznie z planu wdrożenia w formacie markdown i nie powinny powielać ani powtarzać żadnej pracy wykonanej w sekcji analizy.\n\nPamiętaj, aby zapisać swój plan wdrożenia jako .ai/view-implementation-plan.md. Upewnij się, że plan jest szczegółowy, przejrzysty i zapewnia kompleksowe wskazówki dla zespołu programistów.",
    "devD205ApiImplementation": "Twoim zadaniem jest wdrożenie endpointa interfejsu API REST w oparciu o podany plan wdrożenia. Twoim celem jest stworzenie solidnej i dobrze zorganizowanej implementacji, która zawiera odpowiednią walidację, obsługę błędów i podąża za wszystkimi logicznymi krokami opisanymi w planie.\n\nNajpierw dokładnie przejrzyj dostarczony plan wdrożenia:\n\n<implementation_plan>\n{{endpoint-implementation-plan}} <- dodaj referencję do planu implementacji endpointa (np. @generations-endpoint-implementation-plan.md)\n</implementation_plan>\n\n<types>\n{{types}} <- dodaj referencje do definicji typów (np. @types)\n</types>\n\n<implementation_rules>\n{{backend-rules}} <- dodaj referencje do reguł backendowych (np. @shared.mdc, @backend.mdc, @astro.mdc)\n</implementation_rules>\n\n<implementation_approach>\nRealizuj maksymalnie 3 kroki planu implementacji, podsumuj krótko co zrobiłeś i opisz plan na 3 kolejne działania - zatrzymaj w tym momencie pracę i czekaj na mój feedback.\n</implementation_approach>\n\nTeraz wykonaj następujące kroki, aby zaimplementować punkt końcowy interfejsu API REST:\n\n1. Przeanalizuj plan wdrożenia:\n   - Określ metodę HTTP (GET, POST, PUT, DELETE itp.) dla punktu końcowego.\n   - Określenie struktury adresu URL punktu końcowego\n   - Lista wszystkich oczekiwanych parametrów wejściowych\n   - Zrozumienie wymaganej logiki biznesowej i etapów przetwarzania danych\n   - Zwróć uwagę na wszelkie szczególne wymagania dotyczące walidacji lub obsługi błędów.\n\n2. Rozpocznij implementację:\n   - Rozpocznij od zdefiniowania funkcji punktu końcowego z prawidłowym dekoratorem metody HTTP.\n   - Skonfiguruj parametry funkcji w oparciu o oczekiwane dane wejściowe\n   - Wdrożenie walidacji danych wejściowych dla wszystkich parametrów\n   - Postępuj zgodnie z logicznymi krokami opisanymi w planie wdrożenia\n   - Wdrożenie obsługi błędów dla każdego etapu procesu\n   - Zapewnienie właściwego przetwarzania i transformacji danych zgodnie z wymaganiami\n   - Przygotowanie struktury danych odpowiedzi\n\n3. Walidacja i obsługa błędów:\n   - Wdrożenie dokładnej walidacji danych wejściowych dla wszystkich parametrów\n   - Używanie odpowiednich kodów statusu HTTP dla różnych scenariuszy (np. 400 dla błędnych żądań, 404 dla nie znaleziono, 500 dla błędów serwera).\n   - Dostarczanie jasnych i informacyjnych komunikatów o błędach w odpowiedzi.\n   - Obsługa potencjalnych wyjątków, które mogą wystąpić podczas przetwarzania.\n\n4. Rozważania dotyczące testowania:\n   - Należy rozważyć edge case'y i potencjalne problemy, które powinny zostać przetestowane.\n   - Upewnienie się, że wdrożenie obejmuje wszystkie scenariusze wymienione w planie.\n\n5. Dokumentacja:\n   - Dodaj jasne komentarze, aby wyjaśnić złożoną logikę lub ważne decyzje\n   - Dołącz dokumentację dla głównej funkcji i wszelkich funkcji pomocniczych.\n\nPo zakończeniu implementacji upewnij się, że zawiera wszystkie niezbędne importy, definicje funkcji i wszelkie dodatkowe funkcje pomocnicze lub klasy wymagane do implementacji.\n\nJeśli musisz przyjąć jakieś założenia lub masz jakiekolwiek pytania dotyczące planu implementacji, przedstaw je przed pisaniem kodu.\n\nPamiętaj, aby przestrzegać najlepszych praktyk projektowania REST API, stosować się do wytycznych dotyczących stylu języka programowania i upewnić się, że kod jest czysty, czytelny i dobrze zorganizowany.",
    "dev01Refactor": "Przeprowadź refaktoryzację poniższego kodu:\n\n```typescript\nexport class UserAuth {\n  users = [];\n  sessions = new Map();\n  blockedIPs = [\"192.168.1.1\", \"10.0.0.1\"];\n\n  registerUser(\n    username,\n    email,\n    password,\n    age,\n    country,\n    marketing,\n    referralCode\n  ) {\n    if (password.length < 8) return {error: \"Password too short\"};\n    if (age < 13) return {error: \"User too young\"};\n\n    const passwordHash = this.hashPassword(password);\n    const user = {\n      id: this.users.length + 1,\n      username,\n      email,\n      passwordHash,\n      loginAttempts: 0,\n      isLocked: false,\n    };\n\n    this.users.push(user);\n\n    this.sendEmail(email, \"Welcome!\");\n    if (referralCode) {\n    }\n\n    return {success: true, userId: user.id};\n  }\n\n  login(email, password, ip, rememberMe) {\n    if (this.blockedIPs.includes(ip)) return {error: \"IP blocked\"};\n\n    const user = this.users.find((u) => u.email === email);\n    if (!user) return {error: \"User not found\"};\n    if (user.isLocked) return {error: \"Account locked\"};\n\n    if (user.passwordHash !== this.hashPassword(password)) {\n      user.loginAttempts++;\n      if (user.loginAttempts >= 3) {\n        user.isLocked = true;\n        this.sendEmail(email, \"Account locked!\");\n      }\n      return {error: \"Invalid password\"};\n    }\n\n    const sessionId = Math.random().toString(36).substring(2);\n    const days = rememberMe ? 30 : 1;\n    const expiry = new Date(Date.now() + days * 24 * 60 * 60 * 1000);\n\n    this.sessions.set(sessionId, {userId: user.id, expiry});\n\n    return {success: true, sessionId};\n  }\n\n  hashPassword(password) {\n    return password.split(\"\").reverse().join(\"\");\n  }\n\n  sendEmail(email, subject) {\n    console.log(`Sending \"${subject}\" to ${email}`);\n  }\n\n  addReferralPoints(code, points) {\n    console.log(`Adding ${points} points for referral code ${code}`);\n  }\n}\n```\n",
    "dev02AnalysisSol": "Porównaj Angulara i Reacta, a następnie przedstaw swoją rekomendację do projektów client-side.\n\nZanim rozpoczniesz, zadaj mi 5 dodatkowych pytań, aby uzyskać więcej kontekstu na temat projektu i moich kryteriów oceny.\n",
    "dev02Analysis": "Porównaj Angulara i Reacta, a następnie przedstaw swoją rekomendację do projektów client-side.\n",
    "dev03Codebase": "Czy w projekcie znajdują się już funkcje/serwisy z AI?\n",
    "dev03Debug": "Przeanalizuj poniższy ticket dotyczący aplikacji do tworzenia fiszek w #codebase. Twoim zadaniem jest:\n\n- Dokładnie zidentyfikować problem – określ, na czym polega błąd, jakie są konsekwencje dla użytkowników oraz jakie nieprawidłowości w działaniu aplikacji powoduje.\n- Zasugerować potencjalne rozwiązanie – opisz, jakie kroki walidacyjne (zarówno po stronie klienta, jak i serwera) mogłyby zapobiec zapisywaniu pustych fiszek. Uwzględnij, że rozwiązanie powinno również wyświetlać komunikat informujący użytkownika o konieczności uzupełnienia wymaganych pól.\n- Nie implementuj kodu – podaj jedynie dokładne sugestie, które mogą pomóc w usunięciu zgłoszonego błędu.\n\nTicket #41: Błąd pozwalający na tworzenie pustych fiszek\n\nPriorytet: Wysoki\nStatus: Otwarty\nKategoria: Błąd aplikacji\nZgłoszony przez: Anna Nowak (anna.nowak@email.com)\nData zgłoszenia: 09.03.2025, 09:45\n\nOpis problemu:\nUżytkownik zgłasza, że aplikacja pozwala na utworzenie i zapisanie pustej fiszki – bez pytania, bez odpowiedzi lub obu. Takie fiszki powodują problemy podczas nauki, ponieważ pojawiają się puste ekrany lub wyświetlany jest tylko jeden z elementów (tylko pytanie lub tylko odpowiedź).\n\nKroki do reprodukcji:\n\n- Przejdź do opcji \"Utwórz nową fiszkę\"\n- Pozostaw pole \"Pytanie\" puste\n- Opcjonalnie: wpisz odpowiedź lub pozostaw także to pole puste\n- Kliknij przycisk \"Zapisz\"\n- System zapisuje fiszkę pomimo braku treści w wymaganych polach\n\nInformacje dodatkowe:\n\n- Problem występuje we wszystkich poziomach trudności.\n- Puste fiszki zaburzają proces nauki, powodując wyświetlanie pustych ekranów lub fragmentarycznych treści.\n- Użytkownik musi ręcznie usuwać puste fiszki.\n- Brak walidacji formularza informującej o konieczności uzupełnienia pól.\n\nProponowane rozwiązanie:\n\n- Dodanie walidacji po stronie klienta i serwera, która uniemożliwi zapisanie fiszki bez wypełnienia pól 'pytania' i 'odpowiedzi' oraz wyświetli odpowiedni komunikat dla użytkownika.\n\nNa podstawie powyższych informacji, zidentyfikuj główną przyczynę błędu oraz opisz potencjalne podejście do jego rozwiązania. Nie implementuj zmian bez mojej zgody.\n",
    "dev04E2eBase": "Jesteś doświadczonym inżynierem automatyzacji testów, którego zadaniem jest generowanie testów end-to-end (e2e) przy użyciu Playwright i implementacja wzorca Page Object Model (POM). Będziesz pracować w środowisku IDE, aby stworzyć solidny zestaw testów dla aplikacji internetowej.\n\nNajpierw dokładnie przejrzyj opis aplikacji, user stories i ścieżki użytkownika.\n\nOpis aplikacji:\n<app_description>\n{{APP_DESCRIPTION}}\n</app_description>\n\nUser stories:\n<app_user_stories>\n{{APP_USER_STORIES}}\n</app_user_stories>\n\nOpis ścieżek użytkownika:\n<app_flow>\n{{APP_FLOW}}\n</app_flow>\n\nTwoim zadaniem jest wygenerowanie kompletnego zestawu testów przy użyciu Playwright i TypeScript, implementując wzorzec Page Object Model (POM). Postępuj zgodnie z poniższymi krokami i najlepszymi praktykami:\n\n1. Przeanalizuj strukturę aplikacji i przepływ użytkownika:\n\n- Zidentyfikuj kluczowe strony i ich elementy\n- Zaplanuj klasy POM i ich metody\n- Zarys przypadków testowych, aby objąć cały przepływ użytkownika\n- Rozważ potencjalne przypadki brzegowe i scenariusze błędów\n\n2. Tworzenie klas POM:\n\n- Wygeneruj oddzielną klasę dla każdej strony w aplikacji.\n- Zdefiniuj lokalizatory elementów w każdej klasie\n- Zaimplementuj metody dla interakcji użytkownika\n\n3. Implementacja języka TypeScript z Playwright:\n\n- Użyj TypeScript dla silnego typowania i lepszego wsparcia IDE\n- Wykorzystanie wbudowanego w Playwright narzędzia do uruchamiania testów i asercji\n\n4. Zastosowanie zasad POM:\n\n- Centralizacja lokalizatorów elementów w jednym miejscu w każdej klasie strony\n- Tworzenie metod wysokiego poziomu reprezentujących działania użytkownika\n- Wdrożenie nawigacji od strony do strony, która zwraca instancje odpowiednich klas POM\n- Minimalizacja powielania kodu\n\n5. Generowanie przypadków testowych:\n\n- Utwórz przypadki testowe obejmujące cały przepływ użytkownika\n- Upewnij się, że testy są odizolowane i mogą być uruchamiane niezależnie.\n- Skoncentruj się na testowaniu zachowań widocznych dla użytkownika, a nie na szczegółach implementacji.\n\n6. Wdrażanie najlepszych praktyk:\n\n- Używaj wbudowanych lokalizatorów Playwright (np. getByRole, getByText) zamiast selektorów CSS lub XPath, jeśli to możliwe.\n- Zaimplementuj odpowiednie mechanizmy oczekiwania przy użyciu funkcji automatycznego oczekiwania Playwright.\n- Unikanie testowania zależności od stron trzecich poprzez wyśmiewanie żądań sieciowych, gdy jest to konieczne.\n- Używaj miękkich asercji w stosownych przypadkach, aby wychwycić wiele awarii w jednym przebiegu testowym.\n\n7. Dostarczenie kompletnej implementacji zestawu testów:\n\n- Używaj bloków kodu typescript dla każdego pliku\n- Dołącz komentarze wyjaśniające kluczowe części kodu\n- Upewnij się, że wszystkie pliki niezbędne dla zestawu testów są dołączone (np. klasy POM, pliki testowe, pliki konfiguracyjne)\n\nPamiętaj, aby przestrzegać następujących zasad:\n\n- Testuj zachowanie widoczne dla użytkownika\n- Wykonuj testy tak odizolowane, jak to tylko możliwe\n- Unikaj testowania zależności stron trzecich\n- Używaj wbudowanych lokalizatorów i asercji Playwright\n- Zaimplementuj odpowiednią obsługę błędów i logowanie Przed dostarczeniem kompletnej implementacji zestawu testów, przeprowadź dokładną analizę aplikacji i wymagań testowych.\n\nZapisz swoją analizę wewnątrz tagów <test_suite_analysis>, w tym:\n\n1. Listę kluczowych stron i ich ważnych elementów\n2. Zarys klas POM, które planujesz utworzyć i ich główne metody\n3. Listę przypadków testowych, które obejmą cały przepływ użytkownika\n4. Potencjalne przypadki brzegowe i scenariusze błędów do uwzględnienia w testach Końcowe wyniki powinny składać się z analizy zestawu testów, a następnie kompletnej implementacji zestawu testów, w tym wszystkich niezbędnych plików i bloków kodu.\n\nNie dołączaj żadnych dodatkowych wyjaśnień ani podsumowań poza kodem i jego komentarzami. Przykładowa struktura wyjściowa (zastąp rzeczywistą implementacją):\ntypescript\n// Plik: LoginPage.ts\nimport { Page } from '@playwright/test';\n\nexport class LoginPage {\nconstructor(private page: Page) {}\n\n// Lokalizatory elementów\nprivate usernameInput = this.page.getByLabel('Username');\nprivate passwordInput = this.page.getByLabel('Password');\nprivate loginButton = this.page.getByRole('button', { name: 'Zaloguj' });\n\n// Metody\nasync login(username: string, password: string) {\nawait this.usernameInput.fill(username);\nawait this.passwordInput.fill(password);\nawait this.loginButton.click();\n}\n}\n\n// Dodatkowe klasy POM...\n\n// Plik: login.spec.ts\nimport { test, expect } from '@playwright/test';\nimport { LoginPage } from './LoginPage';\n\ntest('udane logowanie', async ({ page }) => {\nconst loginPage = new LoginPage(page);\nawait page.goto('https://example.com/login');\nawait loginPage.login('testuser', 'password123');\nawait expect(page).toHaveURL('https://example.com/dashboard');\n});\n\n// Dodatkowe przypadki testowe...\n\n```\n\nZapewnij analizę zestawu testów i pełną implementację zestawu testów teraz.\n```\n",
    "dev04E2eThinking": "Jesteś doświadczonym inżynierem automatyzacji testów, którego zadaniem jest generowanie testów end-to-end (e2e) przy użyciu Playwright i implementacja wzorca Page Object Model (POM). Będziesz pracować w środowisku IDE, aby stworzyć solidny zestaw testów dla aplikacji internetowej.\n\nNajpierw dokładnie przejrzyj opis aplikacji, user stories i ścieżki użytkownika.\n\nOpis aplikacji:\n<app_description>\n{{APP_DESCRIPTION}}\n</app_description>\n\nUser stories:\n<app_user_stories>\n{{APP_USER_STORIES}}\n</app_user_stories>\n\nOpis ścieżek użytkownika:\n<app_flow>\n{{APP_FLOW}}\n</app_flow>\n\nTwoim zadaniem jest wygenerowanie kompletnego zestawu testów przy użyciu Playwright i TypeScript, implementując wzorzec Page Object Model (POM). Postępuj zgodnie z poniższymi krokami i najlepszymi praktykami:\n\n1. Utwórz klasy POM:\n\n- Wygeneruj oddzielną klasę dla każdej strony w aplikacji.\n- Zdefiniuj lokalizatory elementów w każdej klasie.\n- Zaimplementuj metody dla interakcji użytkownika.\n\n2. Zaimplementuj TypeScript z Playwright:\n\n- Użyj TypeScript dla silnego typowania i lepszego wsparcia IDE.\n- Wykorzystanie wbudowanego w Playwright narzędzia do uruchamiania testów i asercji.\n\n3. Zastosowanie zasad POM:\n\n- Scentralizuj lokalizatory elementów w jednym miejscu w każdej klasie strony.\n- Tworzenie metod wysokiego poziomu reprezentujących działania użytkownika.\n- Zaimplementuj nawigację od strony do strony, która zwraca instancje odpowiednich klas POM.\n- Zminimalizowanie powielania kodu.\n\n4. Generowanie przypadków testowych:\n\n- Utwórz przypadki testowe obejmujące cały przepływ użytkownika.\n- Upewnij się, że testy są odizolowane i mogą być uruchamiane niezależnie.\n- Skoncentruj się na testowaniu zachowań widocznych dla użytkownika, a nie na szczegółach implementacji.\n\n5. Wdrażaj najlepsze praktyki:\n\n- W miarę możliwości używaj wbudowanych lokalizatorów Playwright (np. getByRole, getByText) zamiast selektorów CSS lub XPath.\n- Zaimplementuj odpowiednie mechanizmy oczekiwania przy użyciu funkcji automatycznego oczekiwania Playwright.\n- Unikaj testowania zależności stron trzecich poprzez wyśmiewanie żądań sieciowych, gdy jest to konieczne.\n- W stosownych przypadkach używaj miękkich asercji, aby wychwycić wiele błędów w jednym przebiegu testowym.\n\nPrzed wygenerowaniem kodu zawiń swój proces myślowy w znaczniki <test_planning> wewnątrz bloku myślenia. Rozważ następujące kwestie:\n\n- Przeanalizuj strukturę aplikacji i przepływ użytkownika\n- Zidentyfikuj kluczowe strony i ich elementy\n- Zaplanuj klasy POM i ich metody\n- Zarys przypadków testowych, aby objąć cały przepływ użytkownika\n- Rozważ potencjalne przypadki brzegowe i scenariusze błędów\n\nPo zakończeniu planowania dostarcz kompletną implementację zestawu testów przy użyciu bloków kodu ``typescript. Dołącz komentarze wyjaśniające kluczowe części kodu.\n\nPamiętaj, aby przestrzegać następujących zasad:\n\n- Testuj zachowanie widoczne dla użytkownika\n- Testy powinny być jak najbardziej odizolowane\n- Unikaj testowania zależności innych firm\n- Używaj wbudowanych w Playwright lokalizatorów i asercji.\n- Zaimplementuj odpowiednią obsługę błędów i rejestrowanie\n\nKońcowy wynik powinien składać się wyłącznie z kompletnej implementacji zestawu testów i nie powinien powielać ani powtarzać żadnej pracy wykonanej w bloku myślenia.\n",
    "dev05Ideation": "Wygeneruj 3 pomysły na zaadresowanie feedbacku klienta poprzez nową funkcjonalność, biorąc pod uwagę stack i obecne ścieżki użytkownika w projekcie “Flashcards”.\n\nOpis projektu:\n<app_description>{{APP_DESCRIPTION}}</app_description>\n\nŚcieżki użytkownika:\n<app_user_flows>{{APP_USER_FLOWS}}</app_user_flows>\n\nFeedback klientów:\n<customer_feedback>{{CUSTOMER_FEEDBACK}}</customer_feedback>\n",
    "dev06Prd": "Utwórz dokument wymagań technicznych dla nowej funkcji aplikacji fiszkowej.\n\nOpis aplikacji fiszkowej:\n<app_description>\n{{APP_DESCRIPTION}}\n</app_description>\n\nPomysł na nową funkcję:\n<twój-plan-nowej-funkcji />\n\nDokument powinien zawierać:\n\n1. Opis funkcji (2-3 zdania)\n2. Historyjki użytkownika (3-5 kluczowych historyjek w formacie Gherkina)\n3. Główne user flows\n4. Rozważania dotyczące UI/UX\n5. Szczegóły implementacji technicznej:\n\n- Wymagania dotyczące frontendu\n- Wymagania dotyczące backendu\n- Potrzebne endpointy API\n- Zmiany w bazie danych\n\n6. Podejście do testowania\n\nSkup się na szczegółach technicznych, a nie na uzasadnieniu biznesowym. Bądź konkretny i praktyczny.\n",
    "lms01Logistics": "Przeanalizuj dane dotyczące dostaw, uwzględniając średni czas dostawy, koszty transportu, liczbę zwrotów, region dostaw i metodę transportu.\n",
    "lms02Sales": "Przeanalizuj dane sprzedażowe, uwzględniając kategorię produktów, promocje i kanały sprzedaży.\n",
    "lms03Finance": "Przeanalizuj dane finansowe, uwzględniając przychody, koszty operacyjne i marże.\n",
    "lms04Hr": "Przeanalizuj dane HR, uwzględniając rotację pracowników, retencję, szkolenia i oceny kompetencji.\n",
    "pms01SaveResults": "Przejrzyj krok po kroku to, co osiągnęliśmy i przygotuj kompleksowe podsumowanie, które mogę przesłać w nowej sesji, abyśmy mogli kontynuować od miejsca, w którym skończyliśmy. Upewnij się, że w sposób dokładny opiszesz wynik analizy klastrowej oraz wnioski z niej płynące.\n",
    "pms02Brainstorm": "Mając na uwadze {OPIS_PROBLEMU}, co ujawniliśmy podczas analizy klastrów komentarzy, gdybyśmy potraktowali to wyzwanie nie jako problem, ale jako szansę, jak moglibyśmy je przedefiniować w kontekście naszego produktu?\n\nOpis produktu:\n{TWÓJ_OPIS_PRODUKTU}\n\nOpis użytkowników: {TWÓJ_OPIS_TYPOWEGO_UŻYTKOWNIKA}\n",
    "pms03Assum": "Wymień wszystkie typowe założenia dotyczące {OPIS_PROBLEMU} w aplikacjach.\n\nJak by to wyglądało, gdyby przeciwieństwo każdego założenia było prawdziwe?",
    "pms04Ideas": "Biorąc pod uwagę nasz produkt i ZASOBY, zaproponuj 10 pomysłów na rozwiązanie problemów {PROBLEM} w produkcie {OPIS_PRODUKTU}, czyniąc aplikację dopasowaną do {PROFIL_UŻYTKOWNIKA}.\n\nZASOBY:\n1. czas = jeden kwartał\n2. zespół = zespół product trio składających się z senior product managera, senior product designera oraz 5 senior developerów\n",
    "pms05Details": "Wybieram do dalszej analizy pomysły {LISTA_POMYSŁÓW}\n\nOpisz pierwszy pomysł szerzej, koncentrując się na:\n\n1. Podstawowej propozycji wartości tej funkcji. W jaki sposób odróżnia się ona od istniejących rozwiązań?\n2. Sposobie, w jaki ta funkcja rozwiązuje problem {OPIS_PROBLEMU}\n3. Argumentach, które skłoniłyby mnie do wybrania tego rozwiązania jako pierwszego\n4. Opisie tego, jak to rozwiązanie daje nam unikalną przewagę konkurencyjną na rynku\n9. Sposobach mierzenia sukcesu i kluczowch wskaźnikach wydajności (KPI)\n5. Opisie MVP możliwym do zrealizowania w jeden kwartał\n6. Usprawnieniu procesu wdrażania naszej aplikacji - podaj wskazówki, które pomogą użytkownikom sprawnie rozpocząć korzystanie z tej funkcji\n7. Ścieżce doświadczenia użytkownika podczas pierwszej interakcji z MVP tej funkcji\n8. Kolejnych ulepszeniach funkcjonalnych lub technologicznych po etapie MVP, jakie można wprowadzić aby zwiększyć jej wydajność lub atrakcyjność dla użytkowników\n",
    "pms06Critic": "Dokonaj krytyki przygotowanych przez Ciebie analiz pomysłów {LISTA_POMYSŁÓW}.\n\nW swojej krytyce rozważ następujące kwestie:\n\n1. Biorąc pod uwagę obecne trendy rynkowe, w jaki sposób pomysł może wymagać dostosowania, aby lepiej zaspokoić potrzeby klientów?\n2. Zbadaj pod kątem potencjalnych wyzwań regulacyjnych lub etycznych. W jaki sposób można im zapobiegawczo zaradzić?\n3. Wymień wszystkie sposoby, w jakie nie powinniśmy rozwiązywać tego problemu. W jaki sposób te \"złe\" pomysły mogą zainspirować te niekonwencjonalne i dobre?\n4. Jak z perspektywy kluczowego interesariusza (np. klienta, pracownika lub dostawcy) zdefiniowaliby oni sedno tego pomysłu?\n5. Zidentyfikuj potencjalne słabości lub niedociągnięcia pomysłu. Jak można im zaradzić?\n6. Z perspektywy kluczowego użytkownika lub interesariusza, jakie ulepszenia można wprowadzić do pomysłu?\n7. Jak można skalować ten pomysł, aby zaspokoić potrzeby większej liczby odbiorców lub rynków? Jakie wyzwania mogą się pojawić?\n8. Zidentyfikuj najbardziej ryzykowny aspekt naszego obecnego pomysłu. Teraz przeprowadź burzę mózgów, aby przekształcić to ryzyko w unikalny punkt sprzedaży.\n9. Zbadaj wpływ pomysłu na koszty. Jak można ją uczynić bardziej opłacalną ekonomicznie?\n10. Jeśli nasz budżet zostałby zmniejszony o 80%, ale nadal musielibyśmy osiągnąć nasze cele, jak byśmy to zrobili?\n11. Wymień wszystkie założenia dotyczące tego pomysłu. Jak by to wyglądało, gdyby przeciwieństwo każdego założenia było prawdziwe?\n\nZacznij od krytyki pierwszego pomysłu {POMYSŁ}.",
    "pms07Onepager": "Napisz podsumowanie kluczowych informacji na temat pomysłu {PROJEKT}. Uwzględnij dogłębną analizę pomysłu oraz jego krytykę, które wykonałeś wcześniej podczas tej rozmowy.\n\nOgólny opis pomysłu: Jak w 3-4 zdaniach streścić sedno {POMYSŁ} w kontekście rozwoju {PRODUKT_2.0}?\n\nCel Projektu: Jakie są główne cele projektu? Czy chodzi o zwiększenie przychodów, poprawę retencji użytkowników, czy inne cele?\n\nAnaliza Rynku: Jakie są aktualne trendy w branży {BRANŻA_FIRMY}, które wpłynęły na koncepcję projekt? Jak konkurenci w branży radzą sobie z funkcjami społecznościowymi?\n\nFunkcjonalności i Technologia: Jakie konkretne funkcjonalności i technologie będą wdrożone w ramach projektu? Jakie narzędzia AI i personalizacji są rozważane do integracji?\n\nModel Biznesowy: Jaki jest planowany model biznesowy dla projektu? Czy będą one darmowe, czy zastosowany zostanie model freemium?\n\nMierzenie Sukcesu: Jakie są konkretne oczekiwania co do KPIs (Key Performance Indicators) dla projektu? Jak zostanie zmierzony wpływ na retencję i satysfakcję użytkowników?\n\nRyzyka i Zarządzanie Kryzysowe: Jakie są przewidziane ryzyka związane z projektem i jakie strategie zarządzania kryzysowego zostały przygotowane?\n\nWnioski: Jak w 3-4 zdaniach podsumować cały projekt?\n",
    "pms20Prfaq": "Na podstawie kontekstu rozmowy napisz dokument \"Press Release/FAQ\" w stylu Amazon dla projektu {PROJEKT}.\n\nDokument powinien zawierać krótką informację prasową o produkcie, symulowane efekty wydania projektu w kontekście mojej firmy oraz gotowe odpowiedzi na 5 pytań, które mogą pojawić się w rozmowie z dziennikarzem.\n\nBądź wszechstronny, logiczny i zwięzły.",
    "pms21PrdBase": "Jako menedżer produktu dla projektu {PROJEKT}, skierowanego do {INFORMACJE_O_UŻYTKOWNIKU}, napisz kompleksowy dokument wymagań produktu (Product Requirements Document - PRD).\n\nPomóż mi w wygenerowaniu tego dokumentu, obejmując następujące obszary:\n\n- **Wprowadzenie:** Krótkie wyjaśnienie wizji, celów i zakresu produktu.\n- **Wymagania funkcjonalne:** Lista podstawowych cech i funkcjonalności dla MVP i przyszłych wydań.\n- **Specyfikacje techniczne:** Nakreślenie architektury technicznej, modeli danych i wymaganych integracji z innymi firmami.\n- **Wymagania UI/UX:** Opisz projekt interfejsu użytkownika, kluczowe przepływy użytkownika i modele interakcji.\n- **Kryteria akceptacji:** Zdefiniuj, co stanowi 'gotową' funkcję lub funkcjonalność.\n- **Mierniki i KPI:** Zidentyfikuj kluczowe wskaźniki wydajności, aby zmierzyć sukces.\n- **Zgodność i bezpieczeństwo:** Wyjaśnij wszelkie kwestie prawne lub związane z bezpieczeństwem.\n- **Timeline** Oszacuj oś czasu rozwoju, w tym kamienie milowe.",
    "pms22PrdExtended": "Teraz, gdy mamy draft PRD dla {PROJEKT}, czy mógłbyś pomóc w jego dopracowaniu?\n\nSzukam wskazówek dotyczących walidacji funkcji, kryteriów akceptacji, wykonalności technicznej oraz udoskonaleń UI/UX.",
    "pms23AcTips": "Jak radzić sobie z trudnościami w zbieraniu jasnych wymagań dotyczących projektu? Jakich technik mogę użyć, aby skutecznie je określić i udokumentować?\n",
    "pms24Ac": "Muszę zdefiniować kryteria akceptacji dla rezultatów projektu {PROJEKT}. Jak mogę zapewnić, że są one kompleksowe i mierzalne?\n",
    "pms25Rtm": "Na podstawie powyższych informacji i zaleceń dot. kryteriów akceptacji dla {PROJEKT}, pomóż mi stworzyć Requirements Traceability Matrix (RTM), aby spełnić wszystkie wymagania. Wygeneruj wstępną wersję RTM.",
    "pms26TechnicalChallenges": "Jakie potencjalne pułapki lub wyzwania techniczne, które możemy napotkać podczas iteracji naszego MVP {PROJEKT} i jak możemy proaktywnie im zaradzić? W swojej analizie wykorzystaj powyższe RTM, kryteria akceptacji oraz PRD.",
    "pms27Accessibility": "Jednym z wyzwań, z którym musimy się zmierzyć jest zapewnienie dostępności {PROJEKT}. Wygeneruj wymagania dostępności dla, które zapewniają zgodność z wytycznymi WCAG 2.1. Pamiętaj, że {PRODUKT} jest dostępny na platformach {PLATFORMY}.\n\nW swojej analizie wykorzystaj powyższe potencjalne wyzwania, RTM, kryteria akceptacji oraz PRD.",
    "pms28SeniorDev": "Jestem menedżerem produktu i przygotowuję się do rozmowy ze senior developerem. Muszę omówić MVP projektu {PROJEKT}, które planujemy dodać do naszego produktu.\n\nChcę wyjaśnić jego cel, problem użytkownika, który rozwiązuje, wszelkie kluczowe kwestie techniczne lub wymagania oraz sposób, w jaki wpisuje się ona w ogólną strategię produktu.\n\nMuszę również wyjaśnić, że senior będzie musiał wybrać zespół czterech programistów i jednego testera do pracy nad tymi funkcjami i poprowadzić ich tak, aby ukończyli pracę w ciągu kwartału.\n\nCzy możesz pomóc mi wymyślić 5 pytań, które starszy programista może mieć po rozmowie? Poza pytaniami przygotuj:\n- wyjaśnienie dlaczego to pytanie jest istotne z punktu widzenia seniora\n- trzy warianty odpowiedzi\n\nW swojej analizie wykorzystaj powyższe potencjalne wyzwania, RTM, kryteria akceptacji oraz PRD.",
    "dbConflicts": "Jesteś specjalistą mediacji i rozwiązywania konfliktów pomiędzy doświadczonymi pracownikami firmy (OSOBA A oraz OSOBA B).\n\nPoniżej przedstawię ci dwa przeciwstawne poglądy na PROBLEM oraz stanowiska obu osób. Twoim zadaniem jest rozwiązanie konfliktu pomiędzy nimi proponując 2 alternatywne ścieżki postępowania, maksymalizujące interesy obu stron jednocześnie.\n\nJeśli potrzebujesz dodatkowego kontekstu, rozpocznij pracę od 3 pytań, które pomogą ci zrozumieć sytuację.\n\nPROBLEM: \"...\"\n\nOSOBA A: \"...\"\n\nOSOBA B: \"...\"\n",
    "dbCot": "Twoim zadaniem jest rozwiązanie problemu opisanego w sekcji PROBLEM, zgodnie z instrukcjami w sekcji INSTRUKCJE.\n\nPROBLEM: \"...\"\n\nINSTRUKCJE:\n\n1. Zrozumienie problemu: Przeanalizuj sytuację i określ kluczowe elementy problemu oraz strony problemu, które są zaangażowane w rozwiązanie problemu (jeśli dotyczy).\n2. Zidentyfikowanie wyzwań: Wypisz trzy główne wyzwania lub przeszkody związane z tym problemem uwzględniając ich konsekwencje.\n3. Rozważanie opcji: Zaproponuj trzy możliwe rozwiązania, uwzględniając ich potencjalne wady i zalety.\n4. Sformułowanie rekomendacji: Na podstawie powyższych analiz wskaż najbardziej optymalne rozwiązanie.\n5. Podsumowanie: Podsumuj cały proces w krótkim podsumowaniu, wyjaśniając tok myślenia i finalną rekomendację.\n",
    "dbExtract": "Twoim zadaniem jest wyłuskanie kluczowych informacji z przedstawionego TEKSTU.\n\nKluczowe informacje, które powinny być wyłuskane z TEKSTU, to:\n\n- Odbiorca TEKSTU\n- Temat TEKSTU\n- Max. 3 główne punkty TEKSTU (krótko)\n- Deadline lub data realizacji (jeśli dotyczy)\n\nTEKST: \"...\"\n",
    "dbMail": "Napisz maila do ODBIORCY na temat punktów z sekcji NOTATKI. Mail powinien spełniać kryteria z sekcji KRYTERIA.\n\nODBIORCA: Pracownicy działu marketingu\nNOTATKI:\n\n- Budżet marketingowy na 2025 potwierdzony\n- Kalendarz w firmowej bazie wiedzy zaktualizowany\n- Dołącza do nas nowy pracownik - Jan Kowalski\n\nKRYTERIA:\n\n- trzy akapity tekstu po polsku\n- zwięzły styl i prosty język\n- zawierające wszystkie informacje z NOTATEK\n- humorystyczne zakończenie\n",
    "dbPanel": "Prowadzisz panel, w którym trzech specjalistów dyskutuje nad TEMATEM DYSKUSJI.\n\nSpecjalistami są:\n\n- Ekspert A (Bill Gates, założyciel firmy Microsoft)\n- Ekspert B (Jeff Bezos, założyciel firmy Amazon)\n- Ekspert C (Jensen Huang, założyciel firmy NVIDIA)\n\nTEMAT DYSKUSJI: \"...\"\n\nKażdy etap panelu składa się z jednej wypowiedzi każdego eksperta.\n\nNa każdym etapie eksperci mogą sprawdzać i oceniacie nawzajem swoją pracę wskazując na wszelkie możliwe błędy w rozumowaniu.\n\nKażda seria wypowiedzi kończy się oczekiwaniem na pytania z sali, które pozwalają ekspertom przejść do kolejnego etapu dyskusji. Bez jasnego pytania NIE WOLNO przechodzić do kolejnego etapu dyskusji.\n",
    "dbSocrates": "Jako doświadczony strateg i kreatywny lider w dziedzinie marketingu, pomagasz mi w przygotowaniu strategii marketingowej na 2025 rok.\n\nKONTEKST FIRMY: Firma zajmuje się produkcją podzespołów w branży automotive. Eksportujemy nasze produkty do 10 krajów, na kilka kontynentów - w tym do USA i do Azji.\n\nNa początku zadaj mi 5 pytań, które pomogą ci zrozumieć moje potrzeby i przejść do pierwszego etapu budowania strategii.\n",
    "dbSummary": "Twoim zadaniem jest podsumowanie przedstawionego TEKSTU.\n\nTEKST: \"...\"\n\n1.) Przeanalizuj podany TEKST i wygeneruj 5 kluczowych pytań, które po uzyskaniu odpowiedzi pozwolą uchwycić główne punkty i podstawowe znaczenie TEKSTU.\n\n2.) Podczas formułowania pytań:\na. Odnieś się do głównego tematu lub argumentu\nb. Zidentyfikuj kluczowe idee wspierające\nc. Podkreśl ważne fakty lub dowody\nd. Ujawnij cel lub perspektywę autora\ne. Zbadaj wszelkie istotne implikacje lub wnioski.\n\n3.) Odpowiedz szczegółowo na wszystkie wygenerowane pytania po kolei.\n\n4.) Przygotuj finalne podsumowanie TEKSTU na 3 akapity.\n",
    "pengFewshotSolution": "Będę przedstawiał ci komentarze klientów a ty powinieneś dopasować je do kategorii pełnym zdaniem:\n\nKategorie: Pozytywny, Neutralny, Negatywny\n\nOto przykłady oczekiwanych odpowiedzi:\n\nPrzykład 1: \"Znakomity produkt w dobrej cenie!\"\nWynik 1: Kategoria - Pozytywny\n\nPrzykład 2: \"Za te pieniądze raczej ok\"\nWynik 2: Kategoria - Neutralny\n\nPrzykład 3: \"Nie polecam, nie działa\"\nWynik 3:\n",
    "pengStorySolution": "Napisz krótką historyjkę o najlepszym sprzedawcy biżuterii w mieście Zielona Góra. Sprzedawca ma na imię Krzysztof.\n",
    "pengStory": "Napisz krótką historyjkę o najlepszym sprzedawcy biżuterii w mieście Zielona Góra.\n",
    "pengAnatomy": "Jako doświadczony mówca na targach i wydarzeniach branżowych związanych z jubilerstwem i luksusowym handlem detalicznym, wygeneruj dla mnie listę 10 pomysłów na prezentacje związane z zastosowaniem Generatywnego AI.\n\nZwróć listę numerowaną. Każdy podpunkt powinien składać się z nazwy i krótkiego opisu prezentacji.\n\nBędę przemawiał do grupy 100 specjalistów, którzy są zainteresowani wykorzystaniem AI w usprawnianiu swoich procesów, tworzeniu nowych produktów i zwiększaniu sprzedaży.\n\nCiekawe tematy prezentacji innych prelegentów:\n\n1. Personalizacja w obsłudze klienta przy użyciu AI\n2. Optymalizacja kosztów produkcji luksusowych produktów\n3. Automatyzacja wizualizacji projektów biżuterii.\n",
    "pengChemicalSolution": "Przedstawię ci DEFINICJĘ trudnego pojęcia z dziedziny chemii. Wyjaśnij ją w 3 akapitach, na poziomie wiedzy ucznia liceum, unikając specjalistycznych terminów.\n\n<DEFINICJA>\nTransformacja grafitu w diament to konwersja alotropowa węgla zachodząca pod ekstremalnym ciśnieniem i wysoką temperaturą, prowadząca do zmiany struktury warstwowej na trójwymiarową sieć o wyjątkowo silnych wiązaniach chemicznych.\n</DEFINICJA>\n",
    "pengChemical": "Transformacja grafitu w diament to konwersja alotropowa węgla zachodząca pod ekstremalnym ciśnieniem i wysoką temperaturą, prowadząca do zmiany struktury warstwowej na trójwymiarową sieć o wyjątkowo silnych wiązaniach chemicznych.\n",
    "pengExcelV1": "Wyjaśnij czym jest tabela przestawna w arkuszu Excel. Wyjaśnienie powinno być krótkie, mieć zaledwie kilka zdań i nie powinno być zbyt dogłębne.\n",
    "pengExcelV2": "Użyj 2-3 zdań do wyjaśnienia tabel przestawnych w arkuszu Excel w sposób zrozumiały dla ucznia liceum.\n",
    "pengFewshot": "Na podstawie przekazanego komentarza oceń jego dopasowanie do jednej z kategorii:\n\nKategorie: Pozytywny, Neutralny, Negatywny\n\nOto komentarz: “Za te pieniądze raczej ok”\n",
    "pengHelloworld": "Program “Hello, World!” to niewielki fragment kodu w większości języków programowania, który służy do zilustrowania podstawowej składni języka.\n",
    "pengIntro": "Określ rodzaj komentarza otrzymanego od użytkownika:\n\nKomentarz: \"Za te pieniądze raczej ok\"\n",
    "pengTestSolution": "Jak ChatGPT może wspomagać pracę w firmie? Zajmujemy się...\n",
    "pengTest": "Jak ChatGPT może wspomagać pracę w firmie?\n",
    "pengTopMethodV1": "Zaproponuj TOP 1 metodykę zarządzania projektami, która pozwoli na zwiększenie efektywności i zmniejszenie kosztów projektu.\n",
    "pengTopMethodV2": "Zaproponuj TOP 1 metodykę zarządzania projektami, która pozwoli na zwiększenie efektywności i zmniejszenie kosztów projektu.\n\nZanim przejdziesz do realizacji zadania, zadaj mi pytania dotyczące brakującego kontekstu i niejasnych szczegółów, które pomogą Ci w realizacji zadania.\n",
    "pengTshirtsCot": "Mamy cztery obiekty (osoby): Daniel, Emily, Marciano i Christina. Każdy obiekt posiada atrybut koszulka, który przyjmuje jedną z wartości: \"czerwony\", \"żółty\", \"zielony\", \"niebieski\". Dodatkowo w systemie jest reguła: Tylko obiekt, który ma koszulka == \"niebieski\", jest oznaczony jako prawdomówny (true). Pozostałe trzy obiekty są kłamcami (false). Każdy obiekt składa oświadczenie, które należy zinterpretować jako warunek: Daniel: \"Marciano ma na sobie czerwoną koszulkę\" Emily: \"Daniel nie ma na sobie żółtego\" Marciano: \"Emily ma na sobie niebieski\" Christina: \"Jutro założę niebieską\" Który obiekt jest prawdomówny i który jaką ma przypisaną wartość koloru koszulki? Przemyśl to krok po kroku.\n",
    "pengTshirtsNoCot": "Mamy cztery obiekty (osoby): Daniel, Emily, Marciano i Christina. Każdy obiekt posiada atrybut koszulka, który przyjmuje jedną z wartości: \"czerwony\", \"żółty\", \"zielony\", \"niebieski\". Dodatkowo w systemie jest reguła: Tylko obiekt, który ma koszulka == \"niebieski\", jest oznaczony jako prawdomówny (true). Pozostałe trzy obiekty są kłamcami (false). Każdy obiekt składa oświadczenie, które należy zinterpretować jako warunek: Daniel: \"Marciano ma na sobie czerwoną koszulkę\" Emily: \"Daniel nie ma na sobie żółtego\" Marciano: \"Emily ma na sobie niebieski\" Christina: \"Jutro założę niebieską\" Który obiekt jest prawdomówny i który jaką ma przypisaną wartość koloru koszulki?\n"
  },
  "en": {
    "cur01Codebase": "@Codebase Onboard me to this project. Let me know about the technologies used and the project structure.\n",
    "cur02Docs": "@DummyJSON Describe the product entity structure that can be fetched from the API.\n",
    "cur03WebDeps": "@Web Are there any newer, lighter, and more secure alternatives to the dependencies I'm using in the project?\n",
    "cur04WebLodash": "@Web Do you suggest any alternatives to Lodash? I'm interested in solutions that are popular and maintained in {CURRENT_YEAR}.\n",
    "cur05UnitIntro": "I want to add unit tests to @Cart.jsx. Let's start with test configuration for the component and a simple smoke test. Remember that we use @Vitest and @React Testing Library in the project.\n",
    "cur06UnitEdge": "Are we missing any test that could cover an edge case?\n",
    "dev01Refactor": "Refactor the following code:\n\n```typescript\nexport class UserAuth {\n  users = [];\n  sessions = new Map();\n  blockedIPs = [\"192.168.1.1\", \"10.0.0.1\"];\n\n  registerUser(\n    username,\n    email,\n    password,\n    age,\n    country,\n    marketing,\n    referralCode\n  ) {\n    if (password.length < 8) return {error: \"Password too short\"};\n    if (age < 13) return {error: \"User too young\"};\n\n    const passwordHash = this.hashPassword(password);\n    const user = {\n      id: this.users.length + 1,\n      username,\n      email,\n      passwordHash,\n      loginAttempts: 0,\n      isLocked: false,\n    };\n\n    this.users.push(user);\n\n    this.sendEmail(email, \"Welcome!\");\n    if (referralCode) {\n      this.addReferralPoints(referralCode, 10);\n    }\n\n    return {success: true, userId: user.id};\n  }\n\n  login(email, password, ip, rememberMe) {\n    if (this.blockedIPs.includes(ip)) return {error: \"IP blocked\"};\n\n    const user = this.users.find((u) => u.email === email);\n    if (!user) return {error: \"User not found\"};\n    if (user.isLocked) return {error: \"Account locked\"};\n\n    if (user.passwordHash !== this.hashPassword(password)) {\n      user.loginAttempts++;\n      if (user.loginAttempts >= 3) {\n        user.isLocked = true;\n        this.sendEmail(email, \"Account locked!\");\n      }\n      return {error: \"Invalid password\"};\n    }\n\n    const sessionId = Math.random().toString(36).substring(2);\n    const days = rememberMe ? 30 : 1;\n    const expiry = new Date(Date.now() + days * 24 * 60 * 60 * 1000);\n\n    this.sessions.set(sessionId, {userId: user.id, expiry});\n\n    return {success: true, sessionId};\n  }\n\n  hashPassword(password) {\n    return password.split(\"\").reverse().join(\"\");\n  }\n\n  sendEmail(email, subject) {\n    console.log(`Sending \"${subject}\" to ${email}`);\n  }\n\n  addReferralPoints(code, points) {\n    console.log(`Adding ${points} points for referral code ${code}`);\n  }\n}\n```\n",
    "dev02AnalysisSol": "Compare Angular and React, then provide your recommendation for client-side projects.\n\nBefore you start, ask me 5 extra questions to get more context about the project.\n",
    "dev02Analysis": "Compare Angular and React, then provide your recommendation for client-side projects.\n",
    "dev03Codebase": "Are there already any AI functions/services in the project?\n",
    "dev03Debug": "Analyse the ticket below about the fiche app in #codebase. Your task is to:\n\n- Identify the exact problem - identify what the error is, what the consequences are for users and what malfunctions in the application cause.\n- Suggest a potential solution - describe what validation steps (both client-side and server-side) could prevent blank fiches from being saved. Include that the solution should also display a message informing the user to complete the required fields.\n- Do not implement the code - just provide precise suggestions that may help to fix the reported error.\n\nTicket #41: Bug allowing the creation of empty fiches\n\nPriority: High\nStatus: Open\nCategory: Application bug\nReported by: Anna Nowak (anna.nowak@email.com)\nDate reported: 09.03.2025, 09:45\n\nProblem description:\nThe user reports that the application allows you to create and save a blank fiche - no question, no answer or both. Such fiches cause problems during learning, as blank screens appear or only one of the items (only question or only answer) is displayed.\n\nSteps to reproduce:\n\n- Go to ‘Create a new fiche’.\n- Leave the ‘Question’ field blank\n- Optional: enter an answer or leave this field blank as well\n- Click the ‘Save’ button\n- The system saves the fiche despite the lack of content in the required fields\n\nAdditional information:\n\n- The problem occurs in all difficulty levels.\n- Empty fiches disrupt the learning process, causing blank screens or fragmented content.\n- The user has to manually remove blank fiches.\n- Lack of form validation informing the user to complete the fields.\n\nProposed solution:\n\n- Add client-side and server-side validation to prevent the fiche from being saved without filling in the ‘question’ and ‘answer’ fields and display an appropriate message to the user.\n\nBased on the above information, identify the root cause of the error and describe a potential approach to resolving it. Do not implement changes without my permission.\n",
    "dev04E2eBase": "You are an experienced test automation engineer tasked with generating end-to-end (e2e) tests using Playwright and implementing the Page Object Model (POM) pattern. You will be working within an IDE environment to create a robust test suite for a web application.\n\nFirst, carefully review the app description, user stories and user flows.\n\nApplication description:\n<app_description>.\n{{APP_DESCRIPTION}}\n</app_description>.\n\nUser stories:\n<app_user_stories>.\n{{APP_USER_STORIES}}\n</app_user_stories>.\n\nUser flows description:\n<app_flow>\n{{APP_FLOW}}\n</app_flow>\n\nYour task is to generate a complete test suite using Playwright and TypeScript, implementing the Page Object Model (POM) pattern. Follow these steps and best practices:\n\n1. Analyze the application structure and user flow:\n\n- Identify key pages and their elements\n- Plan out the POM classes and their methods\n- Outline the test cases to cover the entire user flow\n- Consider potential edge cases and error scenarios\n\n2. Create POM Classes:\n\n- Generate a separate class for each page in the application\n- Define element locators within each class\n- Implement methods for user interactions\n\n3. Implement TypeScript with Playwright:\n\n- Use TypeScript for strong typing and better IDE support\n- Utilize Playwright's built-in test runner and assertions\n\n4. Apply POM Principles:\n\n- Centralize element locators in one place within each page class\n- Create high-level methods representing user actions\n- Implement page-to-page navigation that returns instances of the appropriate POM classes\n- Minimize code duplication\n\n5. Generate Test Cases:\n\n- Create test cases that cover the entire user flow\n- Ensure tests are isolated and can run independently\n- Focus on testing user-visible behavior rather than implementation details\n\n6. Implement Best Practices:\n\n- Use Playwright's built-in locators (e.g., getByRole, getByText) instead of CSS or XPath selectors when possible\n- Implement proper waiting mechanisms using Playwright's auto-waiting feature\n- Avoid testing third-party dependencies by mocking network requests when necessary\n- Use soft assertions where appropriate to catch multiple failures in a single test run\n\n7. Provide the complete test suite implementation:\n\n- Use typescript code blocks for each file - Include comments explaining key parts of the code - Ensure all files necessary for the test suite are included (e.g., POM classes, test files, configuration files) Remember to adhere to the following: - Test user-visible behavior - Make tests as isolated as possible - Avoid testing third-party dependencies - Use Playwright's built-in locators and assertions - Implement proper error handling and logging Before providing the complete test suite implementation, please conduct a thorough analysis of the application and test requirements. Write your analysis inside <test_suite_analysis> tags, including: 1. A list of key pages and their important elements 2. An outline of the POM classes you plan to create and their main methods 3. A list of test cases that will cover the entire user flow 4. Potential edge cases and error scenarios to consider in your tests Your final output should consist of the test suite analysis followed by the complete test suite implementation, including all necessary files and code blocks. Do not include any additional explanations or summaries outside of the code and its comments. Example output structure (replace with actual implementation): typescript\n  // File: LoginPage.ts\n  import { Page } from '@playwright/test';\n\nexport class LoginPage {\nconstructor(private page: Page) {}\n\n// Element locators\nprivate usernameInput = this.page.getByLabel('Username');\nprivate passwordInput = this.page.getByLabel('Password');\nprivate loginButton = this.page.getByRole('button', { name: 'Log in' });\n\n// Methods\nasync login(username: string, password: string) {\nawait this.usernameInput.fill(username);\nawait this.passwordInput.fill(password);\nawait this.loginButton.click();\n}\n}\n\n// Additional POM classes...\n\n// File: login.spec.ts\nimport { test, expect } from '@playwright/test';\nimport { LoginPage } from './LoginPage';\n\ntest('successful login', async ({ page }) => {\nconst loginPage = new LoginPage(page);\nawait page.goto('https://example.com/login');\nawait loginPage.login('testuser', 'password123');\nawait expect(page).toHaveURL('https://example.com/dashboard');\n});\n\n// Additional test cases...\n\n```\n\nProvide the test suite analysis and complete test suite implementation now.\n```\n",
    "dev04E2eThinking": "You are an experienced test automation engineer tasked with generating end-to-end (e2e) tests using Playwright and implementing the Page Object Model (POM) pattern. You will be working within an IDE environment to create a robust test suite for a web application.\n\nFirst, carefully review the app description, user stories and user flows.\n\nApplication description:\n<app_description>.\n{{APP_DESCRIPTION}}\n</app_description>.\n\nUser stories:\n<app_user_stories>.\n{{APP_USER_STORIES}}\n</app_user_stories>.\n\nUser flows description:\n<app_flow>\n{{APP_FLOW}}\n</app_flow>\n\nYour task is to generate a complete test suite using Playwright and TypeScript, implementing the Page Object Model (POM) pattern. Follow these steps and best practices:\n\n1. Create POM Classes:\n\n- Generate a separate class for each page in the application.\n- Define element locators within each class.\n- Implement methods for user interactions.\n\n2. Implement TypeScript with Playwright:\n\n- Use TypeScript for strong typing and better IDE support.\n- Utilize Playwright's built-in test runner and assertions.\n\n3. Apply POM Principles:\n\n- Centralize element locators in one place within each page class.\n- Create high-level methods representing user actions.\n- Implement page-to-page navigation that returns instances of the appropriate POM classes.\n- Minimize code duplication.\n\n4. Generate Test Cases:\n\n- Create test cases that cover the entire user flow.\n- Ensure tests are isolated and can run independently.\n- Focus on testing user-visible behavior rather than implementation details.\n\n5. Implement Best Practices:\n\n- Use Playwright's built-in locators (e.g., getByRole, getByText) instead of CSS or XPath selectors when possible.\n- Implement proper waiting mechanisms using Playwright's auto-waiting feature.\n- Avoid testing third-party dependencies by mocking network requests when necessary.\n- Use soft assertions where appropriate to catch multiple failures in a single test run.\n\nBefore generating the code, wrap your thought process in <test_planning> tags inside your thinking block. Consider the following:\n\n- Analyze the application structure and user flow\n- Identify key pages and their elements\n- Plan out the POM classes and their methods\n- Outline the test cases to cover the entire user flow\n- Consider potential edge cases and error scenarios\n\nAfter your planning, provide the complete test suite implementation using ```typescript code blocks. Include comments explaining key parts of the code.\n\nRemember to adhere to the following:\n\n- Test user-visible behavior\n- Make tests as isolated as possible\n- Avoid testing third-party dependencies\n- Use Playwright's built-in locators and assertions\n- Implement proper error handling and logging\n\nYour final output should consist only of the complete test suite implementation and should not duplicate or rehash any of the work you did in the thinking block.\n",
    "dev05Ideation": "Generate 3 ideas for addressing customer feedback through new functionality, taking into account the stack and current user paths in the ‘Flashcards’ project.\n\nProject description:\n<app_description>{{APP_DESCRIPTION}}</app_description>.\n\nUser paths:\n<app_user_flows>{{APP_USER_FLOWS}}</app_user_flows>.\n\nCustomer feedback:\n<customer_feedback>{{CUSTOMER_FEEDBACK}}</customer_feedback>.\n",
    "dev06Prd": "Create a technical requirements document for a new flashcards app feature.\n\nDescription of the flashcards application:\n<app_description>.\n{{APP_DESCRIPTION}}\n</app_description>.\n\nDescription of the new feature:\n<your-plan-for-new-feature />.\n\nThe document should include:\n\n1. feature description (2-3 sentences)\n2. user stories (3-5 key stories in Gherkin format)\n3. main user flows\n4. UI/UX considerations\n5. technical implementation details:\n\n- Frontend requirements\n- Backend requirements\n- API endpoints needed\n- Database changes\n\n6. Testing approach\n\nFocus on the technical details rather than the business case. Be specific and practical.\n",
    "lms01Logistics": "Analyse delivery data, taking into account average delivery time, transport costs, number of returns, delivery region and transport method.\n",
    "lms02Sales": "Analyse sales data, taking into account product category, promotions and sales channels.\n",
    "lms03Finance": "Analyse the financial data, taking into account revenues, operating costs and margins.\n",
    "lms04Hr": "Analyse HR data, taking into account staff turnover, retention, training and competency assessments.\n",
    "pms01SaveResults": "Review step by step what we have achieved and prepare a comprehensive summary that I can send in a new session so we can continue from where we left off. Make sure to accurately describe the results of the cluster analysis and the conclusions drawn from it.\n",
    "pms02Brainstorm": "Considering {PROBLEM_DESCRIPTION} that we revealed during the cluster analysis of comments, if we treated this challenge not as a problem but as an opportunity, how could we redefine it in the context of our product?\n\nProduct description:\n{YOUR_PRODUCT_DESCRIPTION}\n\nUser description: {YOUR_TYPICAL_USER_DESCRIPTION}\n",
    "pms03Assum": "List all typical assumptions about {PROBLEM_DESCRIPTION} in applications.\n\nWhat would it look like if the opposite of each assumption was true?\n",
    "pms04Ideas": "Taking into account our product and RESOURCES, propose 10 ideas for solving {PROBLEM} problems in the product {PRODUCT_DESCRIPTION}, making the application tailored to {USER_PROFILE}.\n\nRESOURCES:\n\n1. time = one quarter\n2. team = product trio team consisting of a senior product manager, senior product designer and 5 senior developers\n",
    "pms05Details": "I choose the following ideas for further analysis {LIST_OF_IDEAS}\n\nDescribe the first idea in more detail, focusing on:\n\n1. The core value proposition of this feature. How does it differ from existing solutions?\n2. The way this feature solves the problem {PROBLEM_DESCRIPTION}\n3. Arguments that would convince me to choose this solution as the first one\n4. Description of how this solution gives us a unique competitive advantage in the market\n5. Ways to measure success and key performance indicators (KPIs)\n6. Description of an MVP that can be implemented in one quarter\n7. Improving our application's implementation process - provide tips that will help users start using this feature efficiently\n8. User experience path during the first interaction with the MVP of this feature\n9. Further functional or technological improvements after the MVP stage that can be introduced to increase its efficiency or attractiveness to users\n",
    "pms06Critic": "Critique the ideas {LIST_OF_IDEAS} that you have analyzed.\n\nIn your critique, consider the following issues:\n\n1. Given current market trends, how might the idea need to be adapted to better meet customer needs?\n2. Examine potential regulatory or ethical challenges. How can we proactively address them?\n3. List all the ways we should not solve this problem. How can these \"bad\" ideas inspire unconventional and good ones?\n4. How would key stakeholders (e.g., customer, employee, or supplier) define the core of this idea from their perspective?\n5. Identify potential weaknesses or shortcomings of the idea. How can they be addressed?\n6. From the perspective of a key user or stakeholder, what improvements could be made to the idea?\n7. How can this idea be scaled to meet the needs of more users or markets? What challenges might arise?\n8. Identify the riskiest aspect of our current idea. Now brainstorm how to transform this risk into a unique selling point.\n9. Examine the cost impact of the idea. How can it be made more economically viable?\n10. If our budget was cut by 80% but we still had to achieve our goals, how would we do it?\n11. List all assumptions about this idea. What would it look like if the opposite of each assumption was true?\n\nStart with critiquing the first idea {IDEA}.\n",
    "pms07Onepager": "Write a summary of key information about the {PROJECT} idea. Include the in-depth analysis and critique of the idea that you performed earlier in this conversation.\n\nGeneral idea description: How would you summarize the essence of {IDEA} in 3-4 sentences in the context of {PRODUCT_2.0} development?\n\nProject Goal: What are the main goals of the project? Is it about increasing revenue, improving user retention, or other objectives?\n\nMarket Analysis: What are the current trends in the {COMPANY_INDUSTRY} industry that influenced the project concept? How do competitors in the industry handle social features?\n\nFeatures and Technology: What specific features and technologies will be implemented in the project? What AI tools and personalization options are being considered for integration?\n\nBusiness Model: What is the planned business model for the project? Will the features be free, or will a freemium model be applied?\n\nMeasuring Success: What are the specific expectations regarding KPIs (Key Performance Indicators) for the project? How will the impact on user retention and satisfaction be measured?\n\nRisks and Crisis Management: What are the anticipated risks associated with the project and what crisis management strategies have been prepared?\n\nConclusions: How would you summarize the entire project in 3-4 sentences?\n",
    "pms20Prfaq": "Based on the conversation context, write a \"Press Release/FAQ\" document in the Amazon style for the {PROJECT}.\n\nThe document should include a brief press release about the product, simulated effects of the project's release in the context of my company, and ready answers to 5 questions that may arise in discussions with journalists.\n\nBe comprehensive, logical, and concise.\n",
    "pms21PrdBase": "As a product manager for the {PROJECT} project, targeting {USER_INFORMATION}, write a comprehensive Product Requirements Document (PRD).\n\nHelp me generate this document, covering the following areas:\n\n- **Introduction:** A brief explanation of the product's vision, goals, and scope.\n- **Functional Requirements:** A list of core features and functionalities for the MVP and future releases.\n- **Technical Specifications:** An outline of the technical architecture, data models, and required integrations with other companies.\n- **UI/UX Requirements:** Describe the user interface design, key user flows, and interaction patterns.\n- **Acceptance Criteria:** Define what constitutes a 'ready' feature or functionality.\n- **Metrics and KPIs:** Identify key performance indicators to measure success.\n- **Compliance and Security:** Explain any legal or security-related issues.\n- **Timeline:** Estimate the development timeline, including milestones.\n",
    "pms22PrdExtended": "Now that we have a draft PRD for {PROJECT}, could you help refine it?\n\nI'm looking for guidance on feature validation, acceptance criteria, technical feasibility, and UI/UX improvements.\n",
    "pms23AcTips": "How to deal with difficulties in gathering clear project requirements? What techniques can I use to effectively define and document them?\n",
    "pms24Ac": "I need to define acceptance criteria for the results of the {PROJECT} project. How can I ensure they are comprehensive and measurable?\n",
    "pms25Rtm": "Based on the information and acceptance criteria recommendations for {PROJECT} above, help me create a Requirements Traceability Matrix (RTM) to meet all requirements. Generate an initial version of the RTM.\n",
    "pms26TechnicalChallenges": "What potential pitfalls or technical challenges might we encounter during the iteration of our MVP {PROJECT}, and how can we proactively address them? In your analysis, utilize the above RTM, acceptance criteria, and PRD.\n",
    "pms27Accessibility": "One of the challenges we must face is ensuring the accessibility of {PROJECT}. Generate accessibility requirements that ensure compliance with WCAG 2.1 guidelines. Remember that {PRODUCT} is available on {PLATFORMS} platforms.\n\nIn your analysis, utilize the potential challenges, RTM, acceptance criteria, and PRD mentioned above.\n",
    "pms28SeniorDev": "I am a product manager and I am preparing for a conversation with a senior developer. I need to discuss the MVP of the {PROJECT} project, which we plan to add to our product.\n\nI want to explain its purpose, the user problem it solves, any key technical issues or requirements, and how it fits into the overall product strategy.\n\nI also need to explain that the senior will have to select a team of four developers and one tester to work on these features and lead them to complete the work within a quarter.\n\nCan you help me come up with 5 questions that a senior developer might have after the conversation? In addition to the questions, prepare:\n\n- an explanation of why this question is important from a senior's point of view\n- three answer options\n\nIn your analysis, use the potential challenges, RTM, acceptance criteria, and PRD mentioned above.\n",
    "pengAnatomy": "As an experienced speaker at trade shows and industry events related to jewelry and luxury retail, generate for me a list of 10 presentation ideas related to the application of Generative AI.\n\nReturn a numbered list. Each item should consist of a title and a brief description of the presentation.\n\nI will be speaking to a group of 100 specialists who are interested in using AI to streamline their processes, create new products, and increase sales.\n\nInteresting presentation topics from other speakers:\n\n1. Personalization in customer service using AI\n2. Cost optimization in the production of luxury products\n3. Automation of jewelry design visualization.\n",
    "pengChemicalSolution": "I will present you with the DEFINITION of a difficult concept in the field of chemistry. Explain it in 3 paragraphs, at the level of a high school student, avoiding specialized terms.\n\n<DEFINITION>\nThe transformation of graphite into diamond is an allotropic conversion of carbon occurring under extreme pressure and high temperature, leading to a change from a layered structure to a three-dimensional network with exceptionally strong chemical bonds.\n</DEFINITION>\n",
    "pengChemical": "The transformation of graphite into diamond is an allotropic conversion of carbon occurring under extreme pressure and high temperature, leading to a change from a layered structure to a three-dimensional network with exceptionally strong chemical bonds.\n",
    "pengExcelV1": "Explain what a pivot table is in Excel. The explanation should be brief, just a few sentences long and should not be too detailed.\n",
    "pengExcelV2": "Use 2-3 sentences to explain pivot tables in Excel in a way that a high school student would understand.\n",
    "pengFewshot": "Based on the given comment, evaluate its fit into one of the categories:\n\nCategories: Positive, Neutral, Negative\n\nHere is the comment: \"I think the value for money is good\"\n",
    "pengHelloworld": "The \"Hello, World!\" program is a small piece of code in most programming languages that serves to illustrate the basic syntax of the language.\n",
    "pengIntro": "Determine the type of comment received from the user:\n\nComment: \"For this price it's okay I guess\"\n",
    "pengTestSolution": "How can ChatGPT help in a company? We are working on...\n",
    "pengTest": "How can ChatGPT help in a company?\n",
    "pengTopMethodV1": "Suggest TOP 1 project management methodology that will help increase efficiency and reduce project costs.\n",
    "pengTopMethodV2": "Suggest TOP 1 project management methodology that will help increase efficiency and reduce project costs.\n\nBefore proceeding with the task, ask me questions about missing context and unclear details that will help you complete the task.\n",
    "pengTshirtsCot": "Daniel, Emily, Marciano and Christina are wearing solid colored t-shirts.\n\nTheir t-shirts are red, yellow, green and blue. Only the person wearing the blue t-shirt is telling the truth, while the other three are lying. They make the following statements: Daniel: \"Marciano is wearing a red t-shirt\". Emily: \"Daniel is not wearing yellow\". Marciano: \"Emily is wearing blue\". Christina: \"Tomorrow I will wear blue\".\n\nCan you determine the color of each person's t-shirt and can we expect Christina to wear blue tomorrow? Solve this problem step by step.\n",
    "pengTshirtsNoCot": "Daniel, Emily, Marciano and Christina are wearing solid colored t-shirts.\n\nTheir t-shirts are red, yellow, green and blue. Only the person wearing the blue t-shirt is telling the truth, while the other three are lying. They make the following statements: Daniel: \"Marciano is wearing a red t-shirt\". Emily: \"Daniel is not wearing yellow\". Marciano: \"Emily is wearing blue\". Christina: \"Tomorrow I will wear blue\".\n\nCan you determine the color of each person's t-shirt and can we expect Christina to wear blue tomorrow? Give a quick answer without breaking down the task step by step.\n"
  }
}